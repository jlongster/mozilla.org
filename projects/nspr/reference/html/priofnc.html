<?php

$html_title = ' NSPR Reference: Chapter&#32;10 I/O Functions';

$menu = array(
    'id' => 'default',
);

$extra_headers = '
<META NAME="keywords" CONTENT="electronic commerce, ecommerce, ebusiness, e-business, e-commerce, enterprise software, net economy, Netscape, Sun Microsystems, Sun-Netscape Alliance, iPlanet, internet software">
<META NAME="description" CONTENT="The Sun-Netscape Alliance, a strategic alliance formed by America Online and Sun Microsystems, Inc., is delivering iPlanet e-commerce software and enterprise solutions that enable companies to compete successfully in the Net Economy">
<META NAME="TEMPLATEBASE" CONTENT="Authored in FrameMaker. Converted to HTML in WebWorks Publisher 2000. manual wdt 1.5">
<META NAME="LASTUPDATED" CONTENT="05/18/01 16:04:58">
';

require_once "{$config['file_root']}/includes/header.inc.php"

?>

<MAINCONTENT>

<NAVIGATIONCONTENT>
   <TABLE WIDTH="100%" BORDER="0" CELLSPACING="4">
      <TR>
         <TD VALIGN="TOP">
        
           
           <FONT SIZE="+1"><B>
             NSPR Reference</B></FONT><BR><FONT>  
<FONT SIZE="-1"><b><a href="priotyp.html">
<FONT SIZE="2">Previous</a></FONT>&nbsp;&nbsp;&nbsp;&nbsp;</b>
<a href="index.html">
<b><FONT SIZE="2">Contents</a></FONT></b>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="prntdb.html">
<b>
<FONT SIZE="2">
Next
</a>
</FONT>
</b>&nbsp;&nbsp;&nbsp;&nbsp;</FONT>
         </TD>
     </TR>

     
   </TABLE>
   <BR>
</NAVIGATIONCONTENT>

<BOOKCONTENT>
<HR>
      <center>
<A NAME="17587"> </A><A NAME=""> </A><h2>
Chapter&#32;10 
&nbsp;



<A NAME="17588"> </A><A NAME="I/O Functions"> </A>I/O Functions
</h2>
</center>
<A NAME="17589"> </A>This chapter describes the NSPR functions used to perform operations such as 
system access, normal file I/O, and socket (network) I/O.

<P>

<A NAME="17593"> </A>For sample code that illustrates basic I/O operations, see <A HREF="printro.html#13314"  >Introduction to NSPR</A>. 
For information about the types most commonly used with the functions described 
in this chapter, see <A HREF="priotyp.html#16721"  >Chapter&#32;9 "I/O Types</A>"

<P>

<A NAME="17600"> </A><A HREF="priofnc.html#17626"  >Functions that Operate on Pathnames</A><br>
<A HREF="priofnc.html#17845"  >Functions that Act on File Descriptors</A><br>
<A HREF="priofnc.html#18353"  >Directory I/O Functions</A><br>
<A HREF="priofnc.html#18579"  >Socket Manipulation Functions</A><br>
<A HREF="priofnc.html#19373"  >Converting Between Host and Network Addresses</A><br>
<A HREF="priofnc.html#19466"  >Memory-Mapped I/O Functions</A><br>
<A HREF="priofnc.html#19605"  >Anonymous Pipe Function</A><br>
<A HREF="priofnc.html#19643"  >Polling Functions</A><br>
<A HREF="priofnc.html#19749"  >Manipulating Layers</A>

<P>



<A NAME="17626"> </A>
<A NAME="Functions that Operate on Pathnames"> </A>
<h2>
Functions that Operate on Pathnames
</h2>


<A NAME="17627"> </A>A file or directory in a file system is specified by its pathname. NSPR uses 
Unix-style pathnames, which are null-terminated character strings. Only the ASCII 
character set is supported. The forward slash (<CODE>/</CODE>) separates the directories in a 
pathname. NSPR converts the slashes in a pathname to the directory separator of 
the native OS--for example, backslash (<CODE>\)</CODE> on Windows and colon (<CODE>:</CODE>) on Mac 
OS--before passing it to the native system calls. 

<P>

<A NAME="17628"> </A>Some file systems also differentiate drives or volumes.

<P>

<A NAME="17632"> </A><A HREF="priofnc.html#17649"  ><CODE>PR_Open</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17703"  ><CODE>PR_Delete</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17723"  ><CODE>PR_GetFileInfo</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17758"  ><CODE>PR_GetFileInfo64</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17793"  ><CODE>PR_Rename</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17817"  ><CODE>PR_Access</CODE></A><CODE>
</CODE>
<P>

<A NAME="17649"> </A><A NAME="PR_Open"> </A><h4>
PR_Open
</h4>

<A NAME="17650"> </A>Opens a file for reading, writing, or both. Also used to create a file.

<P>

<BR>
<A NAME="17651"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17652"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17653"></A>PRFileDesc* PR_Open(<br>&nbsp;&nbsp;&nbsp;const char *name, <br>&nbsp;&nbsp;&nbsp;PRIntn flags, <br>&nbsp;&nbsp;&nbsp;PRIntn mode);
</PRE>
<P>
<BR>
<A NAME="17654"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17655"> </A>The function has the following parameters:

<P>

<P>
<A NAME="17686"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17658"></A><CODE>name</CODE>
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17660"> </A>The pathname of the file to be opened.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17662"></A>flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17664"> </A>File status flags. <CODE>PR_Open</CODE> performs a bitwise <CODE>OR</CODE> of the following bit flags:

<P>
<ul>
<B>  <li></B>
<A NAME="17665"> </A><CODE>PR_RDONLY</CODE>. Open for reading only.

<P><B>  <li></B>
<A NAME="17666"> </A><CODE>PR_WRONLY</CODE>. Open for writing only.

<P><B>  <li></B>
<A NAME="17667"> </A><CODE>PR_RDWR</CODE>. Open for reading and writing.

<P><B>  <li></B>
<A NAME="17668"> </A><CODE>PR_CREATE_FILE</CODE>. If the file does not exist, the file is created. If the file 
exists, this flag has no effect.

<P><B>  <li></B>
<A NAME="17669"> </A><CODE>PR_APPEND</CODE>. The file pointer is set to the end of the file prior to each 
write.

<P><B>  <li></B>
<A NAME="21327"> </A><CODE>PR_TRUNCATE</CODE>. If the file exists, its length is truncated to 0.

<P><B>  <li></B>
<A NAME="21357"> </A><CODE>PR_SYNC</CODE>. If set, each write will wait for both the file data and file status 
to be physically updated.

<P><B>  <li></B>
<A NAME="21470"> </A><CODE>PR_EXCL</CODE>. Used with PR_CREATE_FILE; if the file does not exist, the 
file is created. If the file already exists, no action and NULL is returned

<P></ul>

<A NAME="17671"> </A>In most cases, only one of the first three flags may be used. If the <CODE>flags</CODE> 
parameter does include any of the first three flags (<CODE>PR_RDONLY</CODE>, 
<CODE>PR_WRONLY</CODE>, or <CODE>PR_RDWR</CODE>), the open file can't be read or written, which is 
not useful.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17673"></A>mode
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17675"> </A>Access permission bits of the file mode, if the file is created when 
<CODE>PR_CREATE_FILE</CODE> is on. 

<P>

<A NAME="17676"> </A>The <CODE>mode</CODE> parameter is currently applicable only on Unix platforms. It may 
apply to other platforms in the future. Possible values of the <CODE>mode</CODE> 
parameter include the following:

<P>
<ul>
<B>  <li></B>
<A NAME="17677"> </A>00400. Read by owner.

<P><B>  <li></B>
<A NAME="17678"> </A>00200. Write by owner.

<P><B>  <li></B>
<A NAME="17679"> </A>00100. Execute (search if a directory) by owner.

<P><B>  <li></B>
<A NAME="17680"> </A>00040. Read by group.

<P><B>  <li></B>
<A NAME="17681"> </A>00020. Write by group.

<P><B>  <li></B>
<A NAME="17682"> </A>00010. Execute by group.

<P><B>  <li></B>
<A NAME="17683"> </A>00004. Read by others.

<P><B>  <li></B>
<A NAME="17684"> </A>00002. Write by others.

<P><B>  <li></B>
<A NAME="17685"> </A>00001. Execute by others.

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17687"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17688"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17689"> </A>If the file is successfully opened, a pointer to a dynamically allocated 
<A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> for the newly opened file. The <CODE>PRFileDesc</CODE> should be freed by 
calling <A HREF="priofnc.html#17887"  ><CODE>PR_Close</CODE></A>.

<P><B>  <li></B>
<A NAME="17696"> </A>If the file was not opened successfully, a <CODE>NULL</CODE> pointer.

<P></ul>

<BR>
<A NAME="17697"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17701"> </A><CODE>PR_Open</CODE> creates a file descriptor (<A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A>) for the file with the pathname <CODE>name</CODE> 
and sets the file status flags of the file descriptor according to the value of <CODE>flags</CODE>. If 
a new file is created as a result of the <CODE>PR_Open</CODE> call, its file mode bits are set 
according to the <CODE>mode</CODE> parameter. 

<P>

<A NAME="17703"> </A><A NAME="PR_Delete"> </A><h4>
PR_Delete
</h4>

<A NAME="17704"> </A>Deletes a file.

<P>

<BR>
<A NAME="17705"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17706"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17707"></A>PRStatus PR_Delete(const char *name);
</PRE>
<P>
<BR>
<A NAME="17708"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="17709"> </A>The function has the following parameter:

<P>

<P>
<A NAME="17715"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17712"></A>name
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17714"> </A>The pathname of the file to be deleted.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17716"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17717"> </A>One of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17718"> </A>If the file is successfully deleted, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="17719"> </A>If the file is not successfully deleted, <CODE>PR_FAILURE</CODE>.

<P></ul>

<BR>
<A NAME="17720"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17721"> </A>Deletes a file from the file system. The operation may fail if the file is already open.

<P>

<A NAME="17723"> </A><A NAME="PR_GetFileInfo"> </A><h4>
PR_GetFileInfo
</h4>

<A NAME="17724"> </A>Gets information about a file with a specified pathname. File size is expressed as a 
32-bit integer.

<P>

<BR>
<A NAME="17725"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17726"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17727"></A>PRStatus PR_GetFileInfo(<br>&nbsp;&nbsp;&nbsp;const char *fn, <br>&nbsp;&nbsp;&nbsp;PRFileInfo *info);
</PRE>
<P>
<BR>
<A NAME="17728"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17729"> </A>The function has the following parameters:

<P>

<P>
<A NAME="17742"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17732"></A>fn
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17734"> </A>The pathname of the file to get information about.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17736"></A>info
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17741"> </A>A pointer to a file information object (see <A HREF="priotyp.html#17025"  ><CODE>PRFileInfo</CODE></A>). On output, 
<CODE>PR_GetFileInfo</CODE> writes information about the given file to the file 
information object.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17743"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17744"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17745"> </A>If file information is successfully obtained, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="17746"> </A>If file information is not successfully obtained, <CODE>PR_FAILURE</CODE>.

<P></ul>

<BR>
<A NAME="17747"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17748"> </A><CODE>PR_GetFileInfo</CODE> stores information about the file with the specified pathname in 
the <CODE>PRFileInfo</CODE> structure pointed to by <CODE>info</CODE>. The file size is returned as an 
unsigned 32-bit integer.

<P>

<BR>
<A NAME="17749"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="17753"> </A>For the 64-bit version of this function, see <A HREF="priofnc.html#17758"  ><CODE>PR_GetFileInfo64</CODE></A>. To get equivalent 
information on a file that's already open, use <A HREF="priofnc.html#18034"  ><CODE>PR_GetOpenFileInfo</CODE></A>.

<P>

<A NAME="17758"> </A><A NAME="PR_GetFileInfo64"> </A><h4>
PR_GetFileInfo64
</h4>

<A NAME="17759"> </A>Gets information about a file with a specified pathname. File size is expressed as a 
64-bit integer. 

<P>

<BR>
<A NAME="17760"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17761"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17762"></A>PRStatus PR_GetFileInfo64(<br>&nbsp;&nbsp;&nbsp;const char *fn, <br>&nbsp;&nbsp;&nbsp;PRFileInfo64 *info);
</PRE>
<P>
<BR>
<A NAME="17763"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17764"> </A>The function has the following parameters:

<P>

<P>
<A NAME="17777"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17767"></A>fn
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17769"> </A>The pathname of the file to get information about.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17771"></A>info
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17776"> </A>A pointer to a 64-bit file information object (see <A HREF="priotyp.html#17063"  ><CODE>PRFileInfo64</CODE></A>). On 
output, <CODE>PR_GetFileInfo64</CODE> writes information about the given file to the 
file information object.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17778"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17779"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17780"> </A>If file information is successfully obtained, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="17781"> </A>If file information is not successfully obtained, <CODE>PR_FAILURE</CODE>.

<P></ul>

<BR>
<A NAME="17782"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17783"> </A><CODE>PR_GetFileInfo64</CODE> stores information about the file with the specified pathname 
in the <CODE>PRFileInfo64</CODE> structure pointed to by <CODE>info</CODE>. The file size is returned as an 
unsigned 64-bit integer. 

<P>

<BR>
<A NAME="17784"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="17788"> </A>For the 32-bit version of this function, see <A HREF="priofnc.html#17723"  ><CODE>PR_GetFileInfo</CODE></A>. To get equivalent 
information on a file that's already open, use <A HREF="priofnc.html#18072"  ><CODE>PR_GetOpenFileInfo64</CODE></A>.

<P>

<A NAME="17793"> </A><A NAME="PR_Rename"> </A><h4>
PR_Rename
</h4>

<A NAME="17794"> </A>Renames a file.

<P>

<BR>
<A NAME="17795"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17796"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17797"></A>PRStatus PR_Rename(<br>&nbsp;&nbsp;&nbsp;const char *from, <br>&nbsp;&nbsp;&nbsp;const char *to);
</PRE>
<P>
<BR>
<A NAME="17798"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17799"> </A>The function has the following parameters:

<P>

<P>
<A NAME="17809"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17802"></A>from
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17804"> </A>The old name of the file to be renamed.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17806"></A>to
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17808"> </A>The new name of the file.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17810"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17811"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17812"> </A>If file is successfully renamed, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="17813"> </A>If file is not successfully renamed, <CODE>PR_FAILURE</CODE>.

<P></ul>

<BR>
<A NAME="17814"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17815"> </A><CODE>PR_Rename</CODE> renames a file from its old name (<CODE>from)</CODE> to a new name (<CODE>to</CODE>). If a file 
with the new name already exists, <CODE>PR_Rename</CODE> fails with the error code 
<CODE>PR_FILE_EXISTS_ERROR</CODE>. In this case, <CODE>PR_Rename</CODE> does not overwrite the existing 
filename. 

<P>

<A NAME="17817"> </A><A NAME="PR_Access"> </A><h4>
PR_Access
</h4>

<A NAME="17818"> </A>Determines the accessibility of a file.

<P>

<BR>
<A NAME="17819"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17820"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17821"></A>PRStatus PR_Access(<br>&nbsp;&nbsp;&nbsp;const char *name, <br>&nbsp;&nbsp;&nbsp;PRAccessHow how);
</PRE>
<P>
<BR>
<A NAME="17822"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17823"> </A>The function has the following parameters:

<P>

<P>
<A NAME="17836"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17826"></A>name
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17828"> </A>The pathname of the file whose accessibility is to be determined.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17830"></A>how
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17832"> </A>Specifies which access permission to check for. Use one of the following 
values:

<P>
<ul>
<B>  <li></B>
<A NAME="17833"> </A><CODE>PR_ACCESS_READ_OK</CODE>. Test for read permission.

<P><B>  <li></B>
<A NAME="17834"> </A><CODE>PR_ACCESS_WRITE_OK</CODE>. Test for write permission.

<P><B>  <li></B>
<A NAME="17835"> </A><CODE>PR_ACCESS_EXISTS</CODE>. Check existence of file.

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17837"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17838"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17839"> </A>If the requested access is permitted, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="17840"> </A>If the requested access is not permitted, <CODE>PR_FAILURE</CODE>. 

<P></ul>

<BR>
<A NAME="17841"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17842"> </A>This is the declaration for the enumeration <CODE>PRAccessHow</CODE>, used in the <CODE>how</CODE> 
parameter:

<P>

<PRE>
<A NAME="17843"></A>typedef enum PRAccessHow {<br>&nbsp;&nbsp;&nbsp;PR_ACCESS_EXISTS = 1,<br>&nbsp;&nbsp;&nbsp;PR_ACCESS_WRITE_OK = 2,<br>&nbsp;&nbsp;&nbsp;PR_ACCESS_READ_OK = 3<br>} PRAccessHow;
</PRE>
<P>


<A NAME="17845"> </A>
<A NAME="Functions that Act on File Descriptors"> </A>
<h2>
Functions that Act on File Descriptors
</h2>


<A NAME="17849"> </A><A HREF="priofnc.html#17887"  ><CODE>PR_Close</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17910"  ><CODE>PR_Read</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17945"  ><CODE>PR_Write</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#17979"  ><CODE>PR_Writev</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18034"  ><CODE>PR_GetOpenFileInfo</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18072"  ><CODE>PR_GetOpenFileInfo64</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18113"  ><CODE>PR_Seek</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18159"  ><CODE>PR_Seek64</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18206"  ><CODE>PR_Available</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18237"  ><CODE>PR_Available64</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18268"  ><CODE>PR_Sync</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18291"  ><CODE>PR_GetDescType</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18332"  ><CODE>PR_GetSpecialFD</CODE></A><CODE>
</CODE>
<P>

<A NAME="17887"> </A><A NAME="PR_Close"> </A><h4>
PR_Close
</h4>

<A NAME="17888"> </A>Closes a file descriptor. 

<P>

<BR>
<A NAME="17889"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17890"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17891"></A>PRStatus PR_Close(PRFileDesc *fd);
</PRE>
<P>
<BR>
<A NAME="17892"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="17893"> </A>The function has the following parameter:

<P>

<P>
<A NAME="17902"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17896"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17901"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object. 

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17903"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17904"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17905"> </A>If file descriptor is closed successfully, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="17906"> </A>If the file descriptor is not closed successfully, <CODE>PR_FAILURE</CODE>. 

<P></ul>

<BR>
<A NAME="17907"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17908"> </A>The file descriptor may represent a normal file, a socket, or an end point of a pipe. 
On successful return, <CODE>PR_Close</CODE> frees the dynamic memory and other resources 
identified by the <CODE>fd</CODE> parameter.

<P>

<A NAME="17910"> </A><A NAME="PR_Read"> </A><h4>
PR_Read
</h4>

<A NAME="17911"> </A>Reads bytes from a file or socket.

<P>

<BR>
<A NAME="17912"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17913"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17914"></A>PRInt32 PR_Read(PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void *buf, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRInt32 amount);
</PRE>
<P>
<BR>
<A NAME="17915"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17916"> </A>The function has the following parameters:

<P>

<P>
<A NAME="17933"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17919"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17924"> </A>A pointer to the <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object for the file or socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17926"></A>buf
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17928"> </A>A pointer to a buffer to hold the data read in. On output, the buffer 
contains the data.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17930"></A>amount
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17932"> </A>The size of <CODE>buf</CODE> (in bytes).

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17934"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17935"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17936"> </A>A positive number indicates the number of bytes actually read in.

<P><B>  <li></B>
<A NAME="17937"> </A>The value 0 means end of file is reached or the network connection is closed.

<P><B>  <li></B>
<A NAME="17938"> </A>The value -1 indicates a failure. To get the reason for the failure, call 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="17942"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17943"> </A>The thread invoking <CODE>PR_Read</CODE> blocks until it encounters an end-of-stream 
indication, some positive number of bytes (but no more than <CODE>amount</CODE> bytes) are 
read in, or an error occurs. 

<P>

<A NAME="17945"> </A><A NAME="PR_Write"> </A><h4>
PR_Write
</h4>

<A NAME="17946"> </A>Writes a buffer of data to a file or socket.

<P>

<BR>
<A NAME="17947"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17948"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17949"></A>PRInt32 PR_Write(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;const void *buf,<br>&nbsp;&nbsp;&nbsp;PRInt32 amount);
</PRE>
<P>
<BR>
<A NAME="17950"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17951"> </A>The function has the following parameters:

<P>

<P>
<A NAME="17968"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17954"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17959"> </A>A pointer to the <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object for a file or socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17961"></A>buf
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17963"> </A>A pointer to the buffer holding the data to be written.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17965"></A>amount
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17967"> </A>The amount of data, in bytes, to be written from the buffer.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="17969"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="17970"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="17971"> </A>A positive number indicates the number of bytes successfully written.

<P><B>  <li></B>
<A NAME="17972"> </A>The value -1 indicates that the operation failed. The reason for the failure is 
obtained by calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="17976"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="17977"> </A>The thread invoking <CODE>PR_Write</CODE> blocks until all the data is written or the write 
operation fails. Therefore, the return value is equal to either <CODE>amount</CODE> (success) or -1 
(failure). Note that if <CODE>PR_Write</CODE> returns -1, some data (less than <CODE>amount</CODE> bytes) may 
have been written before an error occurred. 

<P>

<A NAME="17979"> </A><A NAME="PR_Writev"> </A><h4>
PR_Writev
</h4>

<A NAME="17980"> </A>Writes data to a socket from multiple buffers.

<P>

<BR>
<A NAME="17981"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="17982"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="17983"></A>PRInt32 PR_Writev(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRIOVec *iov, <br>&nbsp;&nbsp;&nbsp;PRInt32 size, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<PRE>
<A NAME="17984"></A>#define PR_MAX_IOVECTOR_SIZE 16
</PRE>
<P>
<BR>
<A NAME="17985"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="17986"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18010"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17989"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17994"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object for a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="17996"></A>iov
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="17998"> </A>An array of <CODE>PRIOVec</CODE> structures that describe the buffers to write from.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18000"></A>size
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18002"> </A>Number of <CODE>PRIOVec</CODE> structures in the <CODE>iov</CODE> array. The value of this 
parameter must not be greater than <CODE>PR_MAX_IOVECTOR_SIZE</CODE>. If it is, 
the function will fail and the error will be set to 
<CODE>PR_BUFFER_OVERFLOW_ERROR</CODE>.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18004"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18009"> </A>A value of type <A HREF="prinrvl.html#20947"  ><CODE>PRIntervalTime</CODE></A> describing the time limit for 
completion of the entire write operation.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18011"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18012"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18013"> </A>A positive number indicates the number of bytes successfully written.

<P><B>  <li></B>
<A NAME="18014"> </A>The value -1 is an indication that the operation failed. The reason for the failure 
can be obtained by calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18018"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18019"> </A>The thread calling <CODE>PR_Writev</CODE> blocks until all the data is written or the write 
operation fails. Therefore, the return value is equal to either the sum of all the 
buffer lengths (on success) or -1 (on failure). Note that if <CODE>PR_Writev</CODE> returns -1, part 
of the data may have been written before an error occurred. If the <CODE>timeout</CODE> 
parameter is not <CODE>PR_INTERVAL_NO_TIMEOUT</CODE> and all the data cannot be written in 
the specified interval, <CODE>PR_Writev</CODE> returns -1 with the error code 
<CODE>PR_IO_TIMEOUT_ERROR</CODE>. 

<P>

<A NAME="18020"> </A>This is the type definition for <CODE>PRIOVec</CODE>: 

<P>

<PRE>
<A NAME="18021"></A>typedef struct PRIOVec {<br>&nbsp;&nbsp;&nbsp;char *iov_base;<br>&nbsp;&nbsp;&nbsp;int iov_len;<br>} PRIOVec;
</PRE>
<P>
<A NAME="18022"> </A>The <CODE>PRIOVec</CODE> structure has the following fields: 

<P>

<P>
<A NAME="18032"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18025"></A>iov_base
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18027"> </A>A pointer to the beginning of the buffer.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18029"></A>iov_len
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18031"> </A>The size of the buffer.

<P>
</TD>
  </TR>
</TABLE>


<P>


<A NAME="18034"> </A><A NAME="PR_GetOpenFileInfo"> </A><h4>
PR_GetOpenFileInfo
</h4>

<A NAME="18035"> </A>Gets an open file's information. File size is expressed as a 32-bit integer.

<P>

<BR>
<A NAME="18036"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18037"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18038"></A>PRStatus PR_GetOpenFileInfo(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRFileInfo *info);
</PRE>
<P>
<BR>
<A NAME="18039"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18040"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18056"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18043"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18048"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object for an open file.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18050"></A>info
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18055"> </A>A pointer to a <A HREF="priotyp.html#17025"  ><CODE>PRFileInfo</CODE></A> object. On output, information about the given 
file is written into the file information object.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18057"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18058"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18059"> </A>If file information is successfully obtained, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18060"> </A>If file information is not successfully obtained, <CODE>PR_FAILURE</CODE>.

<P></ul>

<BR>
<A NAME="18061"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18062"> </A><CODE>PR_GetOpenFileInfo</CODE> obtains the file type (normal file, directory, or other), file size 
(as a 32-bit integer), and the file creation and modification times of the open file 
represented by the file descriptor. 

<P>

<BR>
<A NAME="18063"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18067"> </A>For the 64-bit version of this function, see <A HREF="priofnc.html#18072"  ><CODE>PR_GetOpenFileInfo64</CODE></A>. To get 
equivalent information on a file that's not already open, use <A HREF="priofnc.html#17723"  ><CODE>PR_GetFileInfo</CODE></A>.

<P>

<A NAME="18072"> </A><A NAME="PR_GetOpenFileInfo64"> </A><h4>
PR_GetOpenFileInfo64
</h4>

<A NAME="18073"> </A>Gets an open file's information. File size is expressed as a 64-bit integer.

<P>

<BR>
<A NAME="18074"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18075"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18076"></A>PRStatus PR_GetOpenFileInfo64(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRFileInfo64 *info);
</PRE>
<P>
<BR>
<A NAME="18077"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18078"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18094"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18081"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18086"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object for an open file.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18088"></A>info
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18093"> </A>A pointer to a <A HREF="priotyp.html#17063"  ><CODE>PRFileInfo64</CODE></A> object. On output, information about 
the specified file is written into the file information object.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18095"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18096"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18097"> </A>If file information is successfully obtained, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18098"> </A>If file information is not successfully obtained, <CODE>PR_FAILURE</CODE>.

<P></ul>

<BR>
<A NAME="18099"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18103"> </A><CODE>PR_GetOpenFileInfo64</CODE> is the 64-bit version of <A HREF="priofnc.html#18034"  ><CODE>PR_GetOpenFileInfo</CODE></A>. It obtains 
the file type (normal file, directory, or other), file size (as a 64-bit integer), and the 
creation and modification times of the open file represented by the file descriptor. 

<P>

<BR>
<A NAME="18104"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18108"> </A>For the 32-bit version of this function, see <A HREF="priofnc.html#18034"  ><CODE>PR_GetOpenFileInfo</CODE></A>. To get equivalent 
information on a file that's not already open, use <A HREF="priofnc.html#17758"  ><CODE>PR_GetFileInfo64</CODE></A>.

<P>

<A NAME="18113"> </A><A NAME="PR_Seek"> </A><h4>
PR_Seek
</h4>

<A NAME="18114"> </A>Moves the current read-write file pointer by an offset expressed as a 32-bit integer.

<P>

<BR>
<A NAME="18115"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18116"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18117"></A>PRInt32 PR_Seek(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRInt32 offset, <br>&nbsp;&nbsp;&nbsp;PRSeekWhence whence);
</PRE>
<P>
<BR>
<A NAME="18118"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18119"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18142"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18122"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18127"> </A>Pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18129"></A>offset
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18131"> </A>A value, in bytes, used with the <CODE>whence</CODE> parameter to set the file 
pointer. A negative value causes seeking in the reverse direction.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18133"></A>whence
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18138"> </A>A value of type <A HREF="priotyp.html#17467"  ><CODE>PRSeekWhence</CODE></A> that specifies how to interpret the 
<CODE>offset</CODE> parameter in setting the file pointer associated with the <CODE>fd</CODE> 
parameter. The value for the <CODE>whence</CODE> parameter can be one of the 
following:

<P>
<ul>
<B>  <li></B>
<A NAME="18139"> </A><CODE>PR_SEEK_SET</CODE>. Sets the file pointer to the value of the <CODE>offset</CODE> 
parameter.

<P><B>  <li></B>
<A NAME="18140"> </A><CODE>PR_SEEK_CUR</CODE>. Sets the file pointer to its current location plus the 
value of the <CODE>offset</CODE> parameter.

<P><B>  <li></B>
<A NAME="18141"> </A><CODE>PR_SEEK_END</CODE>. Sets the file pointer to the size of the file plus the 
value of the <CODE>offset</CODE> parameter.

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18143"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18144"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18145"> </A>If the function completes successfully, the resulting pointer location, measured 
in bytes from the beginning of the file.

<P><B>  <li></B>
<A NAME="18146"> </A>If the function fails, the file pointer remains unchanged and the function 
returns the value -1. The error code can then be retrieved with <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18150"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18151"> </A>Here's an idiom for obtaining the current location of the file pointer for the file 
descriptor in the <CODE>fd</CODE> parameter: 

<P>

<PRE>
<A NAME="18152"></A>PR_Seek(fd, 0, PR_SEEK_CUR)
</PRE>
<P>
<BR>
<A NAME="18153"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18154"> </A>If you need to move the file pointer by a large offset that's out of the range of a 
32-bit integer, use <A HREF="priofnc.html#18159"  ><CODE>PR_Seek64</CODE></A>. 

<P>

<A NAME="18159"> </A><A NAME="PR_Seek64"> </A><h4>
PR_Seek64
</h4>

<A NAME="18160"> </A>Moves the current read-write file pointer by an offset expressed as a 64-bit integer.

<P>

<BR>
<A NAME="18161"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18162"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18163"></A>PRInt64 PR_Seek64(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRInt64 offset, <br>&nbsp;&nbsp;&nbsp;PRSeekWhence whence);
</PRE>
<P>
<BR>
<A NAME="18164"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18165"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18188"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18168"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18173"> </A>Pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18175"></A>offset
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18177"> </A>A value, in bytes, that is used with the <CODE>whence</CODE> parameter to set the file 
pointer. A negative value causes seeking in the reverse direction.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18179"></A>whence
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18184"> </A>A value of type <A HREF="priotyp.html#17467"  ><CODE>PRSeekWhence</CODE></A> that specifies how to interpret the 
<CODE>offset</CODE> parameter in setting the file pointer associated with the <CODE>fd</CODE> 
parameter. The value for the <CODE>whence</CODE> parameter can be one of the 
following:

<P>
<ul>
<B>  <li></B>
<A NAME="18185"> </A><CODE>PR_SEEK_SET</CODE>. Sets the file pointer to the value of the <CODE>offset</CODE> 
parameter.

<P><B>  <li></B>
<A NAME="18186"> </A><CODE>PR_SEEK_CUR</CODE>. Sets the file pointer to its current location plus the 
value of the <CODE>offset</CODE> parameter.

<P><B>  <li></B>
<A NAME="18187"> </A><CODE>PR_SEEK_END</CODE>. Sets the file pointer to the size of the file plus the 
value of the <CODE>offset</CODE> parameter.

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18189"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18190"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18191"> </A>If the function completes successfully, the resulting pointer location, measured 
in bytes from the beginning of the file.

<P><B>  <li></B>
<A NAME="18192"> </A>If the function fails, the file offset remains unchanged and the function returns 
the value -1. The error code can then be retrieved via <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18196"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18197"> </A>This is the idiom for obtaining the current location (expressed as a 64-bit integer) of 
the file pointer for the file descriptor in the <CODE>fd</CODE> parameter:

<P>

<PRE>
<A NAME="18198"></A>PR_Seek64(fd, 0, PR_SEEK_CUR)
</PRE>
<P>
<A NAME="18199"> </A>If the native operating system is capable of handling only a 32-bit file offset, 
<CODE>PR_Seek64</CODE> may fail with the error code <CODE>PR_FILE_TOO_BIG_ERROR</CODE> if the offset 
parameter is out of the range of a 32-bit integer. 

<P>

<BR>
<A NAME="18200"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18204"> </A><A HREF="priofnc.html#18113"  ><CODE>PR_Seek</CODE></A>.

<P>

<A NAME="18206"> </A><A NAME="PR_Available"> </A><h4>
PR_Available
</h4>

<A NAME="18207"> </A>Determines the number of bytes (expressed as a 32-bit integer) that are available for 
reading beyond the current read-write pointer in a specified file or socket. 

<P>

<BR>
<A NAME="18208"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18209"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18210"></A>PRInt32 PR_Available(PRFileDesc *fd);
</PRE>
<P>
<BR>
<A NAME="18211"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="18212"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18221"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18215"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18220"> </A>Pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a file or socket.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18222"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18223"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18224"> </A>If the function completes successfully, it returns the number of bytes that are 
available for reading. For a normal file, these are the bytes beyond the current 
file pointer.

<P><B>  <li></B>
<A NAME="18225"> </A>If the function fails, it returns the value -1. The error code can then be retrieved 
via <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18229"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18230"> </A><CODE>PR_Available</CODE> works on normal files and sockets. <CODE>PR_Available</CODE> does not work 
with pipes on Win32 platforms.

<P>

<BR>
<A NAME="18231"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18232"> </A>If the number of bytes available for reading is out of the range of a 32-bit integer, 
use <A HREF="priofnc.html#18237"  ><CODE>PR_Available64</CODE></A>.

<P>

<A NAME="18237"> </A><A NAME="PR_Available64"> </A><h4>
PR_Available64
</h4>

<A NAME="18238"> </A>Determines the number of bytes (expressed as a 64-bit integer) that are available for 
reading beyond the current read-write pointer in a specified file or socket. 

<P>

<BR>
<A NAME="18239"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18240"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18241"></A>PRInt64 PR_Available64(PRFileDesc *fd);
</PRE>
<P>
<BR>
<A NAME="18242"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="18243"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18252"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18246"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18251"> </A>Pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a file or socket.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18253"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18254"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18255"> </A>If the function completes successfully, it returns the number of bytes that are 
available for reading. For a normal file, these are the bytes beyond the current 
file pointer.

<P><B>  <li></B>
<A NAME="18256"> </A>If the function fails, it returns the value -1. The error code can then be retrieved 
via <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18260"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18261"> </A><CODE>PR_Available64</CODE> works on normal files and sockets. <CODE>PR_Available</CODE> does not work 
with pipes on Win32 platforms.

<P>

<BR>
<A NAME="18262"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18263"> </A>If the number of bytes available for reading is within the range of a 32-bit integer, 
use <A HREF="priofnc.html#18206"  ><CODE>PR_Available</CODE></A>.

<P>

<A NAME="18268"> </A><A NAME="PR_Sync"> </A><h4>
PR_Sync
</h4>

<A NAME="18269"> </A>Synchronizes any buffered data for a file descriptor to its backing device (disk).

<P>

<BR>
<A NAME="18270"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18271"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18272"></A>PRStatus PR_Sync(PRFileDesc *fd);
</PRE>
<P>
<BR>
<A NAME="18273"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="18274"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18283"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18277"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18282"> </A>Pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a file.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18284"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18285"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18286"> </A>On successful completion, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18287"> </A>If the function fails, <CODE>PR_FAILURE</CODE>.

<P></ul>

<BR>
<A NAME="18288"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18289"> </A><CODE>PR_Sync</CODE> writes all the in-memory buffered data of the specified file to the disk. 

<P>

<A NAME="18291"> </A><A NAME="PR_GetDescType"> </A><h4>
PR_GetDescType
</h4>

<A NAME="18292"> </A>Describes what type of file is referenced by a specified file descriptor. 

<P>

<BR>
<A NAME="18293"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18294"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18295"></A>PRDescType PR_GetDescType(PRFileDesc *file);
</PRE>
<P>
<BR>
<A NAME="18296"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18297"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18306"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18300"></A>file
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18305"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object whose descriptor type is to be 
returned.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18307"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18308"> </A>The function returns a <CODE>PRDescType</CODE> enumeration constant that describes the type of 
file.

<P>

<BR>
<A NAME="18309"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18310"> </A>The <CODE>PRDescType</CODE> enumeration is defined as follows:

<P>

<PRE>
<A NAME="18311"></A>typedef enum PRDescType {<br>&nbsp;&nbsp;&nbsp;PR_DESC_FILE &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= 1,<br>&nbsp;&nbsp;&nbsp;PR_DESC_SOCKET_TCP = 2,<br>&nbsp;&nbsp;&nbsp;PR_DESC_SOCKET_UDP = 3,<br>&nbsp;&nbsp;&nbsp;PR_DESC_LAYERED &nbsp;&nbsp;&nbsp;= 4<br>} PRDescType;
</PRE>
<P>
<A NAME="18312"> </A>The enumeration has the following enumerators: 

<P>

<P>
<A NAME="18330"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18315"></A>PR_DESC_FILE
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18317"> </A>The <CODE>PRFileDesc</CODE> object represents a normal file.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18319"></A>PR_DESC_SOCKET_TCP
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18321"> </A>The <CODE>PRFileDesc</CODE> object represents a TCP socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18323"></A>PR_DESC_SOCKET_UDP
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18325"> </A>The <CODE>PRFileDesc</CODE> object represents a UDP socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18327"></A>PR_DESC_LAYERED
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18329"> </A>The <CODE>PRFileDesc</CODE> object is a layered file descriptor.

<P>
</TD>
  </TR>
</TABLE>


<P>


<A NAME="18332"> </A><A NAME="PR_GetSpecialFD"> </A><h4>
PR_GetSpecialFD
</h4>

<A NAME="18333"> </A>Gets the file descriptor that represents the standard input, output, or error stream.

<P>

<BR>
<A NAME="18334"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18335"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18336"></A>PRFileDesc* PR_GetSpecialFD(PRSpecialFD id);
</PRE>
<P>
<BR>
<A NAME="18337"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="18338"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18344"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18341"></A>id
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18343"> </A>A pointer to an enumerator of type <CODE>PRSpecialFD</CODE>, indicating the type 
of I/O stream desired: <CODE>PR_StandardInput</CODE>, <CODE>PR_StandardOutput</CODE>, 
or <CODE>PR_StandardError</CODE>.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18345"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18346"> </A>If the <CODE>id</CODE> parameter is valid, <CODE>PR_GetSpecialFD</CODE> returns a file descriptor that 
represents the corresponding standard I/O stream. Otherwise, <CODE>PR_GetSpecialFD</CODE> 
returns <CODE>NULL</CODE> and sets the error to <CODE>PR_INVALID_ARGUMENT_ERROR</CODE>.

<P>

<BR>
<A NAME="18347"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18348"> </A>Type <CODE>PRSpecialFD</CODE> is defined as follows: 

<P>

<PRE>
<A NAME="18349"></A>typedef enum PRSpecialFD{<br>    PR_StandardInput,<br>    PR_StandardOutput,<br>    PR_StandardError<br>} PRSpecialFD;
</PRE>
<P>
<PRE>
<A NAME="18350"></A>#define PR_STDIN&nbsp;&nbsp;&nbsp;PR_GetSpecialFD(PR_StandardInput)<br>#define PR_STDOUT&nbsp;&nbsp;&nbsp;PR_GetSpecialFD(PR_StandardOutput)<br>#define PR_STDERR&nbsp;&nbsp;&nbsp;PR_GetSpecialFD(PR_StandardError)
</PRE>
<P>
<A NAME="18351"> </A>File descriptors returned by <CODE>PR_GetSpecialFD</CODE> are owned by the runtime and 
should not be closed by the caller. 

<P>



<A NAME="18353"> </A>
<A NAME="Directory I/O Functions"> </A>
<h2>
Directory I/O Functions
</h2>


<A NAME="18357"> </A><A HREF="priofnc.html#18371"  ><CODE>PR_OpenDir</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18406"  ><CODE>PR_ReadDir</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18468"  ><CODE>PR_CloseDir</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18505"  ><CODE>PR_MkDir</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18548"  ><CODE>PR_RmDir</CODE></A><CODE>
</CODE>
<P>

<A NAME="18371"> </A><A NAME="PR_OpenDir"> </A><h4>
PR_OpenDir
</h4>

<A NAME="18372"> </A>Opens the directory with the specified pathname.

<P>

<BR>
<A NAME="18373"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18374"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18375"></A>PRDir* PR_OpenDir(const char *name);
</PRE>
<P>
<BR>
<A NAME="18376"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="18377"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18383"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18380"></A>name
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18382"> </A>The pathname of the directory to be opened.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18384"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18385"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18389"> </A>If the directory is successfully opened, a <A HREF="priotyp.html#16759"  ><CODE>PRDir</CODE></A> object is dynamically allocated 
and the function returns a pointer to it.

<P><B>  <li></B>
<A NAME="18390"> </A>If the directory cannot be opened, the function returns <CODE>NULL</CODE>.

<P></ul>

<BR>
<A NAME="18391"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18392"> </A><CODE>PR_OpenDir</CODE> opens the directory specified by the pathname <CODE>name</CODE> and returns a 
pointer to a directory stream (a <A HREF="priotyp.html#16759"  ><CODE>PRDir</CODE></A> object) that can be passed to subsequent 
<A HREF="priofnc.html#18406"  ><CODE>PR_ReadDir</CODE></A> calls to get the directory entries (files and subdirectories) in the 
directory. The <A HREF="priotyp.html#16759"  ><CODE>PRDir</CODE></A> pointer should eventually be closed by a call to <A HREF="priofnc.html#18468"  ><CODE>PR_CloseDir</CODE></A>. 

<P>

<A NAME="18406"> </A><A NAME="PR_ReadDir"> </A><h4>
PR_ReadDir
</h4>

<A NAME="18407"> </A>Gets a pointer to the next entry in the directory.

<P>

<BR>
<A NAME="18408"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18409"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18410"></A>PRDirEntry* PR_ReadDir(<br>&nbsp;&nbsp;&nbsp;PRDir *dir, <br>&nbsp;&nbsp;&nbsp;PRDirFlags flags);
</PRE>
<P>
<BR>
<A NAME="18411"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18412"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18430"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18415"></A>dir
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18420"> </A>A pointer to a <A HREF="priotyp.html#16759"  ><CODE>PRDir</CODE></A> object that designates an open directory.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18422"></A>flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18424"> </A>Specifies which directory entries, if any, to skip. Values can include 
the following:

<P>
<ul>
<B>  <li></B>
<A NAME="18425"> </A><CODE>PR_SKIP_NONE</CODE>. Do not skip any files.

<P><B>  <li></B>
<A NAME="18426"> </A><CODE>PR_SKIP_DOT</CODE>. Skip the directory entry "<CODE>.</CODE>" representing the 
current directory.

<P><B>  <li></B>
<A NAME="18427"> </A><CODE>PR_SKIP_DOT_DOT</CODE>. Skip the directory entry "<CODE>..</CODE>" representing 
the parent directory.

<P><B>  <li></B>
<A NAME="18428"> </A><CODE>PR_SKIP_BOTH</CODE>. Skip both "<CODE>.</CODE>" and "<CODE>..</CODE>"

<P><B>  <li></B>
<A NAME="18429"> </A><CODE>PR_SKIP_HIDDEN</CODE>. Skip hidden files. On Windows platforms and 
the Mac OS, this value identifies files with the "hidden" attribute 
set. On Unix platform, this value identifies files whose names 
begin with a period ("<CODE>.</CODE>").

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18431"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18432"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18433"> </A>A pointer to the next entry in the directory.

<P><B>  <li></B>
<A NAME="18434"> </A>If the end of the directory is reached or an error occurs, <CODE>NULL</CODE>. The reason can be 
retrieved via <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18438"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18439"> </A><CODE>PR_ReadDir</CODE> returns a pointer to a directory entry structure:

<P>

<PRE>
<A NAME="18440"></A>struct PRDirEntry {<br>&nbsp;&nbsp;&nbsp;const char *name;<br>};
</PRE>
<P>
<PRE>
<A NAME="18441"></A>typedef struct PRDirEntry PRDirEntry;
</PRE>
<P>
<A NAME="18442"> </A>The structure has the following field: 

<P>

<P>
<A NAME="18448"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18445"></A>name
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18447"> </A>Name of entry, relative to directory name.

<P>
</TD>
  </TR>
</TABLE>


<P>


<A NAME="18449"> </A>The <CODE>flags</CODE> parameter is an enum of type <CODE>PRDirFlags</CODE>:

<P>

<PRE>
<A NAME="18450"></A>typedef enum PRDirFlags {<br>&nbsp;&nbsp;&nbsp;PR_SKIP_NONE &nbsp;&nbsp;&nbsp;= 0x0,<br>&nbsp;&nbsp;&nbsp;PR_SKIP_DOT &nbsp;&nbsp;&nbsp;&nbsp;= 0x1,<br>&nbsp;&nbsp;&nbsp;PR_SKIP_DOT_DOT = 0x2,<br>&nbsp;&nbsp;&nbsp;PR_SKIP_BOTH &nbsp;&nbsp;&nbsp;= 0x3,<br>&nbsp;&nbsp;&nbsp;PR_SKIP_HIDDEN&nbsp;&nbsp;= 0x4<br>} PRDirFlags;
</PRE>
<P>
<A NAME="18451"> </A>The memory associated with the returned <CODE>PRDirEntry</CODE> structure is managed by 
NSPR. The caller must not free the <CODE>PRDirEntry</CODE> structure. Moreover, the 
<CODE>PRDirEntry</CODE> structure returned by each <CODE>PR_ReadDir</CODE> call is valid only until the next 
<CODE>PR_ReadDir</CODE> or <A HREF="priofnc.html#18468"  ><CODE>PR_CloseDir</CODE></A> call on the same <A HREF="priotyp.html#16759"  ><CODE>PRDir</CODE></A> object. 

<P>

<A NAME="18458"> </A>If the end of the directory is reached, <CODE>PR_ReadDir</CODE> returns <CODE>NULL</CODE>, and <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A> 
returns <CODE>PR_NO_MORE_FILES_ERROR</CODE>. 

<P>

<BR>
<A NAME="18462"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18466"> </A><A HREF="priofnc.html#18371"  ><CODE>PR_OpenDir</CODE></A><CODE>
</CODE>
<P>

<A NAME="18468"> </A><A NAME="PR_CloseDir"> </A><h4>
PR_CloseDir
</h4>

<A NAME="18469"> </A>Closes the specified directory.

<P>

<BR>
<A NAME="18470"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18471"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18472"></A>PRStatus PR_CloseDir(PRDir *dir);
</PRE>
<P>
<BR>
<A NAME="18473"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="18474"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18483"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18477"></A>dir
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18482"> </A>A pointer to a <A HREF="priotyp.html#16759"  ><CODE>PRDir</CODE></A> structure representing the directory to be closed.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18484"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18485"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18486"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18487"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be retrieved via 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18491"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18495"> </A>When a <A HREF="priotyp.html#16759"  ><CODE>PRDir</CODE></A> object is no longer needed, it must be closed and freed with a call to 
<CODE>PR_CloseDir</CODE> call. Note that after a <CODE>PR_CloseDir</CODE> call, any <CODE>PRDirEntry</CODE> object 
returned by a previous <A HREF="priofnc.html#18406"  ><CODE>PR_ReadDir</CODE></A> call on the same <CODE>PRDir</CODE> object becomes invalid. 

<P>

<BR>
<A NAME="18499"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18503"> </A><A HREF="priofnc.html#18371"  ><CODE>PR_OpenDir</CODE></A><CODE>
</CODE>
<P>

<A NAME="18505"> </A><A NAME="PR_MkDir"> </A><h4>
PR_MkDir
</h4>

<A NAME="18506"> </A>Creates a directory with a specified name and access mode.

<P>

<BR>
<A NAME="18507"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18508"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18509"></A>PRStatus PR_MkDir(<br>&nbsp;&nbsp;&nbsp;const char *name, <br>&nbsp;&nbsp;&nbsp;PRIntn mode);
</PRE>
<P>
<BR>
<A NAME="18510"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18511"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18532"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18514"></A>name
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18516"> </A>The name of the directory to be created. All the path components up to but 
not including the leaf component must already exist. 

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18518"></A>mode
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18520"> </A>The access permission bits of the file mode of the new directory if the file is 
created when <CODE>PR_CREATE_FILE</CODE> is on.

<P>

<A NAME="18521"> </A>Caveat: The <CODE>mode</CODE> parameter is currently applicable only on Unix platforms. 
It may be applicable to other platforms in the future.

<P>

<A NAME="18522"> </A>Possible values include the following:

<P>
<ul>
<B>  <li></B>
<A NAME="18523"> </A><CODE>00400</CODE>. Read by owner.

<P><B>  <li></B>
<A NAME="18524"> </A><CODE>00200</CODE>. Write by owner.

<P><B>  <li></B>
<A NAME="18525"> </A><CODE>00100</CODE>. Search by owner.

<P><B>  <li></B>
<A NAME="18526"> </A><CODE>00040</CODE>. Read by group.

<P><B>  <li></B>
<A NAME="18527"> </A><CODE>00020</CODE>. Write by group.

<P><B>  <li></B>
<A NAME="18528"> </A><CODE>00010</CODE>. Search by group.

<P><B>  <li></B>
<A NAME="18529"> </A><CODE>00004</CODE>. Read by others.

<P><B>  <li></B>
<A NAME="18530"> </A><CODE>00002</CODE>. Write by others.

<P><B>  <li></B>
<A NAME="18531"> </A><CODE>00001</CODE>. Search by others.

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18533"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18534"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18535"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18536"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The actual reason can be retrieved via 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18540"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18541"> </A><CODE>PR_MkDir</CODE> creates a new directory with the pathname <CODE>name</CODE>. All the path 
components up to but not including the leaf component must already exist. For 
example, if the pathname of the directory to be created is <CODE>a/b/c/d</CODE>, the directory 
<CODE>a/b/c</CODE> must already exist. 

<P>

<BR>
<A NAME="18542"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18546"> </A><A HREF="priofnc.html#18548"  ><CODE>PR_RmDir</CODE></A>.

<P>

<A NAME="18548"> </A><A NAME="PR_RmDir"> </A><h4>
PR_RmDir
</h4>

<A NAME="18549"> </A>Removes a directory with a specified name.

<P>

<BR>
<A NAME="18550"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18551"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18552"></A>PRStatus PR_RmDir(const char *name);
</PRE>
<P>
<BR>
<A NAME="18553"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="18554"> </A>The function has the following parameter:

<P>

<P>
<A NAME="18560"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18557"></A>name
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18559"> </A>The name of the directory to be removed.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18561"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18562"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18563"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18564"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The actual reason can be retrieved via 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18568"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18569"> </A><CODE>PR_RmDir</CODE> removes the directory specified by the pathname <CODE>name</CODE>. The directory 
must be empty. If the directory is not empty, <CODE>PR_RmDir</CODE> fails and <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A> 
returns the error code <CODE>PR_DIRECTORY_NOT_EMPTY_ERROR</CODE>. 

<P>

<BR>
<A NAME="18573"> </A><A NAME="See also"> </A><h5>
See also
</h5>


<A NAME="18577"> </A><A HREF="priofnc.html#18505"  ><CODE>PR_MkDir</CODE></A>.

<P>



<A NAME="18579"> </A>
<A NAME="Socket Manipulation Functions"> </A>
<h2>
Socket Manipulation Functions
</h2>


<A NAME="18580"> </A>The network programming interface presented here is a socket API modeled after 
the popular Berkeley sockets. Differences include the following: 

<P>
<ul>
<B>  <li></B>
<A NAME="18581"> </A>The blocking socket functions in NSPR take a timeout parameter. 

<P><B>  <li></B>
<A NAME="18588"> </A>Two new functions, <A HREF="priofnc.html#19136"  ><CODE>PR_TransmitFile</CODE></A> and <A HREF="priofnc.html#19189"  ><CODE>PR_AcceptRead</CODE></A>, can exploit the 
new system calls of some operating systems for higher performance. 

<P></ul>

<A NAME="18589"> </A>For a useful supplement to the NSPR documentation, see the textbook <I>Unix 
Network Programming,</I> 2nd Ed., Vol. 1: <I>Networking APIs: Sockets and XTI,</I> by W. 
Richard Stevens (Prentice Hall PTR, 1998).

<P>

<A NAME="18593"> </A><A HREF="priofnc.html#18643"  ><CODE>PR_NewUDPSocket</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18671"  ><CODE>PR_NewTCPSocket</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18727"  ><CODE>PR_Connect</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18779"  ><CODE>PR_Accept</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18833"  ><CODE>PR_Bind</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18877"  ><CODE>PR_Listen</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18909"  ><CODE>PR_Shutdown</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18943"  ><CODE>PR_Recv</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#18989"  ><CODE>PR_Send</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19034"  ><CODE>PR_RecvFrom</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19087"  ><CODE>PR_SendTo</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19136"  ><CODE>PR_TransmitFile</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19189"  ><CODE>PR_AcceptRead</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19250"  ><CODE>PR_GetSockName</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19278"  ><CODE>PR_GetPeerName</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19306"  ><CODE>PR_GetSocketOption</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19337"  ><CODE>PR_SetSocketOption</CODE></A><CODE>
</CODE>
<P>

<A NAME="18643"> </A><A NAME="PR_NewUDPSocket"> </A><h4>
PR_NewUDPSocket
</h4>

<A NAME="18644"> </A>Creates a new UDP socket.

<P>

<BR>
<A NAME="18645"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18646"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18647"></A>PRFileDesc* PR_NewUDPSocket(void);
</PRE>
<P>
<BR>
<A NAME="18648"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18649"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18653"> </A>Upon successful completion, a pointer to the <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object created for the 
newly opened UDP socket.

<P><B>  <li></B>
<A NAME="18654"> </A>If the creation of a new UDP socket failed, <CODE>NULL</CODE>.

<P></ul>

<BR>
<A NAME="18655"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18656"> </A>UDP (User Datagram Protocol) is a connectionless, unreliable datagram protocol of 
the TCP/IP protocol suite. UDP datagrams may be lost or delivered in duplicates 
or out of sequence. 

<P>

<A NAME="18657"> </A><CODE>PR_NewUDPSocket</CODE> creates a new UDP socket. The socket may be bound to a 
well-known port number with <A HREF="priofnc.html#18833"  ><CODE>PR_Bind</CODE></A>. Datagrams can be sent with <A HREF="priofnc.html#19087"  ><CODE>PR_SendTo</CODE></A> 
and received with <A HREF="priofnc.html#19034"  ><CODE>PR_RecvFrom</CODE></A>. When the socket is no longer needed, it should be 
closed with a call to <A HREF="priofnc.html#17887"  ><CODE>PR_Close</CODE></A>. 

<P>

<A NAME="18671"> </A><A NAME="PR_NewTCPSocket"> </A><h4>
PR_NewTCPSocket
</h4>

<A NAME="18672"> </A>Creates a new TCP socket.

<P>

<BR>
<A NAME="18673"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18674"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18675"></A>PRFileDesc* PR_NewTCPSocket(void);
</PRE>
<P>
<BR>
<A NAME="18676"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18677"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18681"> </A>Upon successful completion, a pointer to the <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object created for the 
newly opened TCP socket.

<P><B>  <li></B>
<A NAME="18682"> </A>If the creation of a new TCP socket failed, <CODE>NULL</CODE>.

<P></ul>

<BR>
<A NAME="18683"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18684"> </A>TCP (Transmission Control Protocol) is a connection-oriented, reliable byte-stream 
protocol of the TCP/IP protocol suite. <CODE>PR_NewTCPSocket</CODE> creates a new TCP socket. 
A TCP connection is established by a passive socket (the server) accepting a 
connection setup request from an active socket (the client). Typically, the server 
binds its socket to a well-known port with <A HREF="priofnc.html#18833"  ><CODE>PR_Bind</CODE></A>, calls <A HREF="priofnc.html#18877"  ><CODE>PR_Listen</CODE></A> to start 
listening for connection setup requests, and calls <A HREF="priofnc.html#18779"  ><CODE>PR_Accept</CODE></A> to accept a connection. 
The client makes a connection request using <A HREF="priofnc.html#18727"  ><CODE>PR_Connect</CODE></A>. 

<P>

<A NAME="18697"> </A>After a connection is established, the client and server may send and receive data 
between each other. To receive data, one can call <A HREF="priofnc.html#17910"  ><CODE>PR_Read</CODE></A> or <A HREF="priofnc.html#18943"  ><CODE>PR_Recv</CODE></A>. To send 
data, one can call <A HREF="priofnc.html#17945"  ><CODE>PR_Write</CODE></A>, <A HREF="priofnc.html#17979"  ><CODE>PR_Writev</CODE></A>, <A HREF="priofnc.html#18989"  ><CODE>PR_Send</CODE></A>, or <A HREF="priofnc.html#19136"  ><CODE>PR_TransmitFile</CODE></A>. 
<A HREF="priofnc.html#19189"  ><CODE>PR_AcceptRead</CODE></A> is suitable for use by the server to accept a new client connection 
and read the client's first request in one function call. 

<P>

<A NAME="18722"> </A>A TCP connection can be shut down by <A HREF="priofnc.html#18909"  ><CODE>PR_Shutdown</CODE></A>, and the sockets should be 
closed by <A HREF="priofnc.html#17887"  ><CODE>PR_Close</CODE></A>. 

<P>

<A NAME="18727"> </A><A NAME="PR_Connect"> </A><h4>
PR_Connect
</h4>

<A NAME="18728"> </A>Initiates a connection on a specified socket.

<P>

<BR>
<A NAME="18729"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18730"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18731"></A>PRStatus PR_Connect(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;const PRNetAddr *addr, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="18732"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18733"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18753"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18736"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18741"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18743"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18745"> </A>A pointer to the address of the peer to which the socket is to be 
connected.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18747"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18752"> </A>A value of type <A HREF="prinrvl.html#20947"  ><CODE>PRIntervalTime</CODE></A> specifying the time limit for 
completion of the connect operation.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18754"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18755"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18756"> </A>Upon successful completion of connection setup, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18757"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. Further information can be obtained by calling 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18761"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18762"> </A><CODE>PR_Connect</CODE> is usually invoked on a TCP socket, but it may also be invoked on a 
UDP socket. Both cases are discussed here. 

<P>

<A NAME="18763"> </A>If the socket is a TCP socket, <CODE>PR_Connect</CODE> establishes a TCP connection to the peer. 
If the socket is not bound, it will be bound to an arbitrary local address. 

<P>

<A NAME="18764"> </A><CODE>PR_Connect</CODE> blocks until either the connection is successfully established or an 
error occurs. The function uses the lesser of the provided timeout time or the OS'es connect timeout time. 
Meaning if you specify PR_INTERVAL_NO_TIMEOUT as the timeout, the OS's connection time limit will be used. 

<P>

<A NAME="18765"> </A>If the socket is a UDP socket, there is no connection setup to speak of, since UDP is 
connectionless. If <CODE>PR_Connect</CODE> is invoked on a UDP socket, it has an overloaded 
meaning: <CODE>PR_Connect</CODE> merely saves the specified address as the default peer 
address for the socket, so that subsequently one can send and receive datagrams 
from the socket using <A HREF="priofnc.html#18989"  ><CODE>PR_Send</CODE></A> and <A HREF="priofnc.html#18943"  ><CODE>PR_Recv</CODE></A> instead of the usual <A HREF="priofnc.html#19087"  ><CODE>PR_SendTo</CODE></A> and 
<A HREF="priofnc.html#19034"  ><CODE>PR_RecvFrom</CODE></A>. 

<P>

<A NAME="18779"> </A><A NAME="PR_Accept"> </A><h4>
PR_Accept
</h4>

<A NAME="18780"> </A>Accepts a connection on a specified socket.

<P>

<BR>
<A NAME="18781"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18782"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18783"></A>PRFileDesc* PR_Accept(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRNetAddr *addr, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="18784"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18785"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18808"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18788"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18793"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the rendezvous socket on 
which the caller is willing to accept new connections.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18795"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18800"> </A>A pointer to a structure of type <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A>. On output, this structure 
contains the address of the connecting entity.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18802"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18807"> </A>A value of type <A HREF="prinrvl.html#20947"  ><CODE>PRIntervalTime</CODE></A> specifying the time limit for 
completion of the accept operation.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18809"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18810"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18811"> </A>Upon successful acceptance of a connection, a pointer to a new <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> 
structure representing the newly accepted connection.

<P><B>  <li></B>
<A NAME="18815"> </A>If unsuccessful, <CODE>NULL</CODE>. Further information can be obtained by calling 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18819"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18820"> </A>The socket <CODE>fd</CODE> is a rendezvous socket that has been bound to an address with 
<A HREF="priofnc.html#18833"  ><CODE>PR_Bind</CODE></A> and is listening for connections after a call to <A HREF="priofnc.html#18877"  ><CODE>PR_Listen</CODE></A>. <CODE>PR_Accept</CODE> 
accepts the first connection from the queue of pending connections and creates a 
new socket for the newly accepted connection. The rendezvous socket can still be 
used to accept more connections. 

<P>

<A NAME="18827"> </A>If the <CODE>addr</CODE> parameter is not <CODE>NULL</CODE>, <CODE>PR_Accept</CODE> stores the address of the connecting 
entity in the <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> object pointed to by <CODE>addr</CODE>. 

<P>

<A NAME="18831"> </A><CODE>PR_Accept</CODE> blocks the calling thread until either a new connection is successfully 
accepted or an error occurs. If the timeout parameter is not 
<CODE>PR_INTERVAL_NO_TIMEOUT</CODE> and no pending connection can be accepted before the 
time limit, <CODE>PR_Accept</CODE> returns <CODE>NULL</CODE> with the error code <CODE>PR_IO_TIMEOUT_ERROR</CODE>. 

<P>

<A NAME="18833"> </A><A NAME="PR_Bind"> </A><h4>
PR_Bind
</h4>

<A NAME="18834"> </A>Binds an address to a specified socket.

<P>

<BR>
<A NAME="18835"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18836"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18837"></A>PRStatus PR_Bind(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;const PRNetAddr *addr);
</PRE>
<P>
<BR>
<A NAME="18838"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18839"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18855"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18842"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18847"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18849"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18854"> </A>A pointer to a <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> object representing the address to which the 
socket will be bound.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18856"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18857"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18858"> </A>Upon successful binding of an address to a socket, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18859"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. Further information can be obtained by calling 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18863"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18864"> </A>When a new socket is created, it has no address bound to it. <CODE>PR_Bind</CODE> assigns the 
specified address (also known as <CODE>name</CODE>) to the socket. If you do not care about the 
exact IP address assigned to the socket, set the <CODE>inet.ip</CODE> field of <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> to 
<CODE>PR_htonl(PR_INADDR_ANY)</CODE>. If you do not care about the TCP/UDP port assigned to 
the socket, set the <CODE>inet.port</CODE> field of <CODE>PRNetAddr</CODE> to 0. 

<P>

<A NAME="18871"> </A>Note that if <A HREF="priofnc.html#18727"  ><CODE>PR_Connect</CODE></A> is invoked on a socket that is not bound, it implicitly binds 
an arbitrary address the socket. 

<P>

<A NAME="18875"> </A>Call <A HREF="priofnc.html#19250"  ><CODE>PR_GetSockName</CODE></A> to obtain the address (name) bound to a socket. 

<P>

<A NAME="18877"> </A><A NAME="PR_Listen"> </A><h4>
PR_Listen
</h4>

<A NAME="18878"> </A>Listens for connections on a specified socket.

<P>

<BR>
<A NAME="18879"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18880"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18881"></A>PRStatus PR_Listen(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRIntn backlog);
</PRE>
<P>
<BR>
<A NAME="18882"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18895"> </A>The function has the following parameters:<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18885"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18890"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket that will be used 
to listen for new connections.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18892"></A>backlog
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18894"> </A>The maximum length of the queue of pending connections.

<P>
</TD>
  </TR>
</TABLE>



<P>

<BR>
<A NAME="18896"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18897"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18898"> </A>Upon successful completion of listen request, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18899"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. Further information can be obtained by calling 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18903"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18904"> </A><CODE>PR_Listen</CODE> turns the specified socket into a rendezvous socket. It creates a queue 
for pending connections and starts to listen for connection requests on the socket. 
The maximum size of the queue for pending connections is specified by the 
<CODE>backlog</CODE> parameter. Pending connections may be accepted by calling <A HREF="priofnc.html#18779"  ><CODE>PR_Accept</CODE></A>. 

<P>

<A NAME="18909"> </A><A NAME="PR_Shutdown"> </A><h4>
PR_Shutdown
</h4>

<A NAME="18910"> </A>Shuts down part of a full-duplex connection on a specified socket.

<P>

<BR>
<A NAME="18911"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18912"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18913"></A>PRStatus PR_Shutdown(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRShutdownHow how);
</PRE>
<P>
<BR>
<A NAME="18914"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18915"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18931"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18918"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18923"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a connected socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18925"></A>how
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18927"> </A>The kind of disallowed operations on the socket. Possible values include the 
following:

<P>
<ul>
<B>  <li></B>
<A NAME="18928"> </A><CODE>PR_SHUTDOWN_RCV</CODE>. Further receives will be disallowed.

<P><B>  <li></B>
<A NAME="18929"> </A><CODE>PR_SHUTDOWN_SEND</CODE>. Further sends will be disallowed.

<P><B>  <li></B>
<A NAME="18930"> </A><CODE>PR_SHUTDOWN_BOTH</CODE>. Further sends and receives will be disallowed.

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18932"> </A><A NAME="Returns<br>"> </A><h5>
Returns<br>
</h5>


<A NAME="18933"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18934"> </A>Upon successful completion of shutdown request, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="18935"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. Further information can be obtained by calling 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18939"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18940"> </A>The <CODE>PRShutdownHow</CODE> enumeration is defined as follows:

<P>

<PRE>
<A NAME="18941"></A>typedef enum PRShutdownHow{<br>&nbsp;&nbsp;&nbsp;PR_SHUTDOWN_RCV = 0,<br>&nbsp;&nbsp;&nbsp;PR_SHUTDOWN_SEND = 1,<br>&nbsp;&nbsp;&nbsp;PR_SHUTDOWN_BOTH = 2<br>} PRShutdownHow;
</PRE>
<P>
<A NAME="18943"> </A><A NAME="PR_Recv"> </A><h4>
PR_Recv
</h4>

<A NAME="18944"> </A>Receives bytes from a connected socket.

<P>

<BR>
<A NAME="18945"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18946"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18947"></A>PRInt32 PR_Recv(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;void *buf, <br>&nbsp;&nbsp;&nbsp;PRInt32 amount, <br>&nbsp;&nbsp;&nbsp;PRIntn flags, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="18948"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18949"> </A>The function has the following parameters:

<P>

<P>
<A NAME="18977"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18952"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18957"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18959"></A>buf
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18961"> </A>A pointer to a buffer to hold the data received.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18963"></A>amount
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18965"> </A>The size of <CODE>buf</CODE> (in bytes).

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18967"></A>flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18969"> </A>This obsolete parameter must always be zero.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18971"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="18976"> </A>A value of type <A HREF="prinrvl.html#20947"  ><CODE>PRIntervalTime</CODE></A> specifying the time limit for completion 
of the receive operation. 

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="18978"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="18979"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="18980"> </A>A positive number indicates the number of bytes actually received.

<P><B>  <li></B>
<A NAME="18981"> </A>The value 0 means the network connection is closed.

<P><B>  <li></B>
<A NAME="18982"> </A>The value -1 indicates a failure. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="18986"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="18987"> </A><CODE>PR_Recv</CODE> blocks until some positive number of bytes are transferred, a timeout 
occurs, or an error occurs. No more than <CODE>amount</CODE> bytes will be transferred.

<P>

<A NAME="18989"> </A><A NAME="PR_Send"> </A><h4>
PR_Send
</h4>

<A NAME="18990"> </A>Sends bytes from a connected socket.

<P>

<BR>
<A NAME="18991"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="18992"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="18993"></A>PRInt32 PR_Send(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;const void *buf, <br>&nbsp;&nbsp;&nbsp;PRInt32 amount,<br>&nbsp;&nbsp;&nbsp;PRIntn flags, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="18994"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="18995"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19023"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="18998"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19003"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19005"></A>buf
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19007"> </A>A pointer to a buffer containing the data to be sent.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19009"></A>amount
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19011"> </A>The size of <CODE>buf</CODE> (in bytes).

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19013"></A>flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19015"> </A>This obsolete parameter must always be zero.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19017"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19022"> </A>A value of type <A HREF="prinrvl.html#20947"  ><CODE>PRIntervalTime</CODE></A> specifying the time limit for 
completion of the send operation.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19024"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19025"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19026"> </A>A positive number indicates the number of bytes successfully sent. If the 
parameter fd is a blocking socket, this number must always equal amount.

<P><B>  <li></B>
<A NAME="19027"> </A>The value -1 indicates a failure. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19031"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19032"> </A><CODE>PR_Send</CODE> blocks until all bytes are sent, a timeout occurs, or an error occurs.

<P>

<A NAME="19034"> </A><A NAME="PR_RecvFrom"> </A><h4>
PR_RecvFrom
</h4>

<A NAME="19035"> </A>Receives bytes from a socket and stores the sending peer's address.

<P>

<BR>
<A NAME="19036"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19037"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19038"></A>PRInt32 PR_RecvFrom(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;void *buf, <br>&nbsp;&nbsp;&nbsp;PRInt32 amount,<br>&nbsp;&nbsp;&nbsp;PRIntn flags, <br>&nbsp;&nbsp;&nbsp;PRNetAddr *addr,<br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="19039"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19040"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19075"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19043"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19048"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19050"></A>buf
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19052"> </A>A pointer to a buffer to hold the data received.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19054"></A>amount
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19056"> </A>The size of <CODE>buf</CODE> (in bytes).

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19058"></A>flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19060"> </A>This obsolete parameter must always be zero.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19062"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19067"> </A>A pointer to the <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> object that will be filled in with the address 
of the sending peer on return.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19069"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19074"> </A>A value of type <A HREF="prinrvl.html#20947"  ><CODE>PRIntervalTime</CODE></A> specifying the time limit for 
completion of the receive operation

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19076"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19077"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19078"> </A>A positive number indicates the number of bytes actually received.

<P><B>  <li></B>
<A NAME="19079"> </A>The value 0 means the network connection is closed.

<P><B>  <li></B>
<A NAME="19080"> </A>The value -1 indicates a failure. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19084"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19085"> </A><CODE>PR_RecvFrom</CODE> receives up to a specified number of bytes from socket, which may or 
may not be connected. The operation blocks until one or more bytes are 
transferred, a timeout has occurred, or there is an error. No more than <CODE>amount</CODE> 
bytes will be transferred. <CODE>PR_RecvFrom</CODE> is usually used with a UDP socket. 

<P>

<A NAME="19087"> </A><A NAME="PR_SendTo"> </A><h4>
PR_SendTo
</h4>

<A NAME="19088"> </A>Sends bytes a socket to a specified destination. 

<P>

<BR>
<A NAME="19089"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19090"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19091"></A>PRInt32 PR_SendTo(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;const void *buf,<br>&nbsp;&nbsp;&nbsp;PRInt32 amount, <br>&nbsp;&nbsp;&nbsp;PRIntn flags, <br>&nbsp;&nbsp;&nbsp;const PRNetAddr *addr, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="19092"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19093"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19125"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19096"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19101"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19103"></A>buf
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19105"> </A>A pointer to a buffer containing the data to be sent.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19107"></A>amount
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19109"> </A>The size of <CODE>buf</CODE> (in bytes).

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19111"></A>flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19113"> </A>This obsolete parameter must always be zero.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19115"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19117"> </A>A pointer to the address of the destination.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19119"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19124"> </A>A value of type <A HREF="prinrvl.html#20947"  ><CODE>PRIntervalTime</CODE></A> specifying a time limit for completion 
of the send operation.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19126"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19127"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19128"> </A>A positive number indicates the number of bytes successfully sent.

<P><B>  <li></B>
<A NAME="19129"> </A>The value -1 indicates a failure. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19133"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19134"> </A><CODE>PR_SendTo</CODE> sends a specified number of bytes from a socket to the specified 
destination address. The calling thread blocks until all bytes are sent, a timeout has 
occurred, or there is an error. 

<P>

<A NAME="19136"> </A><A NAME="PR_TransmitFile"> </A><h4>
PR_TransmitFile
</h4>

<A NAME="19137"> </A>Sends a complete file across a connected socket.

<P>

<BR>
<A NAME="19138"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19139"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19140"></A>PRInt32 PR_TransmitFile(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *networkSocket, <br>&nbsp;&nbsp;&nbsp;PRFileDesc *sourceFile,<br>&nbsp;&nbsp;&nbsp;const void *headers, <br>&nbsp;&nbsp;&nbsp;PRInt32 hlen, <br>&nbsp;&nbsp;&nbsp;PRTransmitFileFlags flags,<br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="19141"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19142"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19176"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19145"></A>networkSocket
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19150"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the connected 
socket to send data over.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19152"></A>sourceFile
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19157"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the file to send.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19159"></A>headers
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19161"> </A>A pointer to the buffer holding the headers to be sent before 
sending data.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19163"></A>hlen
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19165"> </A>Length of the <CODE>headers</CODE> buffer in bytes.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19167"></A>flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19169"> </A>One of the following flags:

<P>
<ul>
<B>  <li></B>
<A NAME="19170"> </A><CODE>PR_TRANSMITFILE_KEEP_OPEN</CODE> indicates that the socket 
will be kept open after the data is sent.

<P><B>  <li></B>
<A NAME="19171"> </A><CODE>PR_TRANSMITFILE_CLOSE_SOCKET</CODE> indicates that the 
connection should be closed immediately after successful 
transfer of the file.

<P></ul>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19173"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19175"> </A>Time limit for completion of the transmit operation.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19177"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19178"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19179"> </A>A positive number indicates the number of bytes successfully written, 
including both the headers and the file.

<P><B>  <li></B>
<A NAME="19180"> </A>The value -1 indicates a failure. If an error occurs while sending the file, the 
<CODE>PR_TRANSMITFILE_CLOSE_SOCKET</CODE> flag is ignored. The reason for the failure 
can be obtained by calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19184"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19185"> </A>The <CODE>PR_TransmitFile</CODE> function sends a complete file (<CODE>sourceFile</CODE>) across a 
connected socket (<CODE>networkSocket</CODE>). If <CODE>headers</CODE> is non-<CODE>NULL</CODE>, <CODE>PR_TransmitFile</CODE> 
sends the headers across the socket before sending the file.

<P>

<A NAME="19186"> </A>The enumeration <CODE>PRTransmitFileFlags</CODE>, used in the <CODE>flags</CODE> parameter, is defined 
as follows:

<P>

<PRE>
<A NAME="19187"></A>typedef enum PRTransmitFileFlags {<br>&nbsp;&nbsp;&nbsp;PR_TRANSMITFILE_KEEP_OPEN = 0,<br>&nbsp;&nbsp;&nbsp;PR_TRANSMITFILE_CLOSE_SOCKET = 1<br>} PRTransmitFileFlags;
</PRE>
<P>
<A NAME="19189"> </A><A NAME="PR_AcceptRead"> </A><h4>
PR_AcceptRead
</h4>

<A NAME="19190"> </A>Accepts a new connection and receives a block of data.

<P>

<BR>
<A NAME="19191"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19192"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19193"></A>PRInt32 PR_AcceptRead(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *listenSock, <br>&nbsp;&nbsp;&nbsp;PRFileDesc **acceptedSock,<br>&nbsp;&nbsp;&nbsp;PRNetAddr **peerAddr, <br>&nbsp;&nbsp;&nbsp;void *buf, <br>&nbsp;&nbsp;&nbsp;PRInt32 amount, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="19194"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19195"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19239"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19198"></A>listenSock
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19203"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket 
descriptor that has been called with the <A HREF="priofnc.html#18877"  ><CODE>PR_Listen</CODE></A> function, 
also known as the rendezvous socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19208"></A>acceptedSock
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19213"> </A>A pointer to a pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object. On return, 
<CODE>*acceptedSock</CODE> points to the <CODE>PRFileDesc</CODE> object for the 
newly connected socket. This parameter is valid only if the 
function return does not indicate failure.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19215"></A>peerAddr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19220"> </A>A pointer a pointer to a <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> object. On return, 
<CODE>peerAddr</CODE> points to the address of the remote socket. The 
<CODE>PRNetAddr</CODE> object that <CODE>peerAddr</CODE> points to will be in the 
buffer pointed to by <CODE>buf</CODE>. This parameter is valid only if the 
function return does not indicate failure.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19222"></A>buf
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19224"> </A>A pointer to a buffer to hold data sent by the peer and the 
peer's address. This buffer must be large enough to receive 
<CODE>amount</CODE> bytes of data and two <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> structures (thus 
allowing the runtime to align the addresses as needed).

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19229"></A>amount
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19231"> </A>The number of bytes of data to receive. Does not include the 
size of the <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> structures. If 0, no data will be read 
from the peer.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19236"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19238"> </A>The timeout interval only applies to the read portion of the 
operation. <CODE>PR_AcceptRead</CODE> blocks indefinitely until the 
connection is accepted; the read will time out after the timeout 
interval elapses.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19240"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19241"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19242"> </A>A positive number indicates the number of bytes read from the peer.

<P><B>  <li></B>
<A NAME="19243"> </A>The value -1 indicates a failure. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19247"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19248"> </A><CODE>PR_AcceptRead</CODE> accepts a new connection and retrieves the newly created socket's 
descriptor and the connecting peer's address. Also, as its name suggests, 
<CODE>PR_AcceptRead</CODE> receives the first block of data sent by the peer.

<P>

<A NAME="19250"> </A><A NAME=" PR_GetSockName"> </A><h4>
PR_GetSockName
</h4>

<A NAME="19251"> </A>Gets network address for a specified socket.

<P>

<BR>
<A NAME="19252"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19253"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19254"></A>PRStatus PR_GetSockName(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRNetAddr *addr);
</PRE>
<P>
<BR>
<A NAME="19255"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19256"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19269"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19259"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19264"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19266"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19268"> </A>On return, the address of the socket.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19270"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19271"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19272"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="19273"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<A NAME="19278"> </A><A NAME="PR_GetPeerName"> </A><h4>
PR_GetPeerName
</h4>

<A NAME="19279"> </A>Gets the network address of the connected peer.

<P>

<BR>
<A NAME="19280"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19281"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19282"></A>PRStatus PR_GetPeerName(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRNetAddr *addr);
</PRE>
<P>
<BR>
<A NAME="19283"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19284"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19297"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19287"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19292"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19294"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19296"> </A>On return, the address of the peer connected to the socket.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19298"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19299"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19300"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="19301"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<A NAME="19306"> </A><A NAME="PR_GetSocketOption"> </A><h4>
PR_GetSocketOption
</h4>

<A NAME="19307"> </A>Retrieves the socket options set for a specified socket.

<P>

<BR>
<A NAME="19308"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19309"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19310"></A>PRStatus PR_GetSocketOption(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRSocketOptionData *data);
</PRE>
<P>
<BR>
<A NAME="19311"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19312"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19328"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19315"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19320"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the socket whose options 
are to be retrieved.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19322"></A>data
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19327"> </A>A pointer to a structure of type <A HREF="priotyp.html#17206"  ><CODE>PRSocketOptionData</CODE></A>. On input, the 
<CODE>option</CODE> field of this structure must be set to indicate which socket option 
to retrieve for the socket represented by the <CODE>fd</CODE> parameter. On output, this 
structure contains the requested socket option data.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19329"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19330"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19331"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="19332"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<A NAME="19337"> </A><A NAME="PR_SetSocketOption"> </A><h4>
PR_SetSocketOption
</h4>

<A NAME="19338"> </A>Sets the socket options for a specified socket.

<P>

<BR>
<A NAME="19339"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19340"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19341"></A>PRStatus PR_SetSocketOption(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd, <br>&nbsp;&nbsp;&nbsp;PRSocketOptionData *data);
</PRE>
<P>
<BR>
<A NAME="19342"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19343"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19359"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19346"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19351"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the socket whose options 
are to be set.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19353"></A>data
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19358"> </A>A pointer to a structure of type <A HREF="priotyp.html#17206"  ><CODE>PRSocketOptionData</CODE></A> specifying the 
options to set.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19360"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19361"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19362"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="19363"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be obtained by 
calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19367"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19368"> </A>On input, the caller must set both the <CODE>option</CODE> and <CODE>value</CODE> fields of the 
<A HREF="priotyp.html#17206"  ><CODE>PRSocketOptionData</CODE></A> object pointed to by the <CODE>data</CODE> parameter. 

<P>



<A NAME="19373"> </A>
<A NAME="Converting Between Host and Network Addresses"> </A>
<h2>
Converting Between Host and Network Addresses
</h2>


<A NAME="19377"> </A><A HREF="priofnc.html#19391"  ><CODE>PR_ntohs</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19407"  ><CODE>PR_ntohl</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19423"  ><CODE>PR_htons</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19439"  ><CODE>PR_htonl</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19455"  ><CODE>PR_FamilyInet</CODE></A><CODE>
</CODE>
<P>

<A NAME="19391"> </A><A NAME="PR_ntohs"> </A><h4>
PR_ntohs
</h4>

<A NAME="19392"> </A>Performs 16-bit conversion from network byte order to host byte order.

<P>

<BR>
<A NAME="19393"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19394"></A>#include &lt;prnetdb.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19395"></A>PRUint16 PR_ntohs(PRUint16 conversion);
</PRE>
<P>
<BR>
<A NAME="19396"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19397"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19403"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19400"></A>conversion
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19402"> </A>The 16-bit unsigned integer, in network byte order, to be converted.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19404"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19405"> </A>The value of the <CODE>conversion</CODE> parameter in host byte order.

<P>

<A NAME="19407"> </A><A NAME="PR_ntohl"> </A><h4>
PR_ntohl
</h4>

<A NAME="19408"> </A>Performs 32-bit conversion from network byte order to host byte order.

<P>

<BR>
<A NAME="19409"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19410"></A>#include &lt;prnetdb.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19411"></A>PRUint32 PR_ntohl(PRUint32 conversion);
</PRE>
<P>
<BR>
<A NAME="19412"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19413"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19419"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19416"></A>conversion
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19418"> </A>The 32-bit unsigned integer, in network byte order, to be converted.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19420"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19421"> </A>The value of the <CODE>conversion</CODE> parameter in host byte order. 

<P>

<A NAME="19423"> </A><A NAME="PR_htons"> </A><h4>
PR_htons
</h4>

<A NAME="19424"> </A>Performs 16 bit conversion from host byte order to network byte order. 

<P>

<BR>
<A NAME="19425"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19426"></A>#include &lt;prnetdb.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19427"></A>PRUint16 PR_htons(PRUint16 conversion);
</PRE>
<P>
<BR>
<A NAME="19428"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19429"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19435"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19432"></A>conversion
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19434"> </A>The 16-bit unsigned integer, in host byte order, to be converted.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19436"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19437"> </A>The value of the <CODE>conversion</CODE> parameter in network byte order.

<P>

<A NAME="19439"> </A><A NAME="PR_htonl"> </A><h4>
PR_htonl
</h4>

<A NAME="19440"> </A>Performs 32-bit conversion from host byte order to network byte order.

<P>

<BR>
<A NAME="19441"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19442"></A>#include &lt;prnetdb.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19443"></A>PRUint32 PR_htonl(PRUint32 conversion);
</PRE>
<P>
<BR>
<A NAME="19444"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19445"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19451"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19448"></A>conversion
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19450"> </A>The 32-bit unsigned integer, in host byte order, to be converted.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19452"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19453"> </A>The value of the <CODE>conversion</CODE> parameter in network byte order. 

<P>

<A NAME="19455"> </A><A NAME="PR_FamilyInet"> </A><h4>
PR_FamilyInet
</h4>

<A NAME="19456"> </A>Gets the value of the address family for Internet Protocol.

<P>

<BR>
<A NAME="19457"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19458"></A>#include &lt;prnetdb.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19459"></A>PRUint16 PR_FamilyInet(void);
</PRE>
<P>
<BR>
<A NAME="19460"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19461"> </A>The value of the address family for Internet Protocol. This is usually <CODE>PR_AF_INET</CODE>, but 
can also be <CODE>PR_AF_INET6</CODE> if IPv6 is enabled. The returned value can be assigned to the 
<CODE>inet.family</CODE> field of a <A HREF="priotyp.html#17138"  ><CODE>PRNetAddr</CODE></A> object. 

<P>



<A NAME="19466"> </A>
<A NAME="Memory-Mapped I/O Functions"> </A>
<h2>
Memory-Mapped I/O Functions
</h2>


<A NAME="19467"> </A>The memory-mapped I/O functions allow sections of a file to be mapped to 
memory regions, allowing read-write accesses to the file to be accomplished by 
normal memory accesses. 

<P>

<A NAME="19468"> </A>Memory-mapped I/O functions are currently implemented
for Unix, Linux, Mac OS X, and Win32 only.

<P>

<A NAME="19470"> </A><A NAME="PR_CreateFileMap"> </A><h4>
PR_CreateFileMap
</h4>

<A NAME="19471"> </A>Creates a file mapping object. 

<P>

<BR>
<A NAME="19472"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19473"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19474"></A>PRFileMap* PR_CreateFileMap(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *fd,<br>&nbsp;&nbsp;&nbsp;PRInt64 size,<br>&nbsp;&nbsp;&nbsp;PRFileMapProtect prot);
</PRE>
<P>
<BR>
<A NAME="19475"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19476"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19496"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19479"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19484"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the file that is to be 
mapped to memory.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19486"></A>size
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19488"> </A>Size of the file specified by <CODE>fd</CODE>.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19490"></A>prot
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19492"> </A>Protection option for read and write accesses of a file mapping. This 
parameter consists of one of the following options:

<P>
<ul>
<B>  <li></B>
<A NAME="19493"> </A><CODE>PR_PROT_READONLY</CODE>. Read-only access.

<P><B>  <li></B>
<A NAME="19494"> </A><CODE>PR_PROT_READWRITE</CODE>. Readable, and write is shared.

<P><B>  <li></B>
<A NAME="19495"> </A><CODE>PR_PROT_WRITECOPY</CODE>. Readable, and write is private 
(copy-on-write).

<P></ul>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19497"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19498"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19502"> </A>If successful, a file mapping of type <A HREF="priotyp.html#17439"  ><CODE>PRFileMap</CODE></A>. 

<P><B>  <li></B>
<A NAME="19503"> </A>If unsuccessful, NULL. 

<P></ul>

<BR>
<A NAME="19504"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19505"> </A>The <CODE>PRFileMapProtect</CODE> enumeration used in the <CODE>prot</CODE> parameter is defined as 
follows:

<P>

<PRE>
<A NAME="19506"></A>typedef enum PRFileMapProtect {<br>&nbsp;&nbsp;&nbsp;PR_PROT_READONLY,<br>&nbsp;&nbsp;&nbsp;PR_PROT_READWRITE,<br>&nbsp;&nbsp;&nbsp;PR_PROT_WRITECOPY<br>} PRFileMapProtect;
</PRE>
<P>
<A NAME="19507"> </A><CODE>PR_CreateFileMap</CODE> only prepares for the mapping a file to memory. The returned 
file-mapping object must be passed to <A HREF="priofnc.html#19516"  ><CODE>PR_MemMap</CODE></A> to actually map a section of the 
file to memory. 

<P>

<A NAME="19514"> </A>The file-mapping object should be closed with a <A HREF="priofnc.html#19576"  ><CODE>PR_CloseFileMap</CODE></A> call when it is 
no longer needed. 

<P>

<A NAME="19516"> </A><A NAME="PR_MemMap"> </A><h4>
PR_MemMap
</h4>

<A NAME="19517"> </A>Maps a section of a file to memory.

<P>

<BR>
<A NAME="19518"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19519"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19520"></A>void* PR_MemMap(<br>&nbsp;&nbsp;&nbsp;PRFileMap *fmap,<br>&nbsp;&nbsp;&nbsp;PRInt64 offset,<br>&nbsp;&nbsp;&nbsp;PRUint32 len);
</PRE>
<P>
<BR>
<A NAME="19521"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19522"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19536"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19525"></A>fmap
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19527"> </A>A pointer to the file-mapping object representing the file to be 
memory-mapped.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19529"></A>offset
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19531"> </A>The starting offset of the section of file to be mapped. The offset must 
be aligned to whole pages.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19533"></A>len
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19535"> </A>Length of the section of the file to be mapped. The length must be a 
multiple of whole pages.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19537"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19538"> </A>The starting address of the memory region to which the section of file is mapped.<B> 
</B>
<P>

<BR>
<A NAME="19539"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19540"> </A><CODE>PR_MemMap</CODE> maps a section of the file represented by the file mapping <CODE>fmap</CODE> to 
memory. The section of the file starts at <CODE>offset</CODE> and has the length <CODE>len</CODE>. 

<P>

<A NAME="19541"> </A>When the file-mapping memory region is no longer needed, it should be 
unmapped with a call to <A HREF="priofnc.html#19546"  ><CODE>PR_MemUnmap</CODE></A>. 

<P>

<A NAME="19546"> </A><A NAME=" PR_MemUnmap"> </A><h4>
PR_MemUnmap
</h4>

<A NAME="19547"> </A>Unmap a memory region that is backed by a memory-mapped file. 

<P>

<BR>
<A NAME="19548"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19549"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19550"></A>PRStatus PR_MemUnmap(<br>&nbsp;&nbsp;&nbsp;void *addr, <br>&nbsp;&nbsp;&nbsp;PRUint32 len);
</PRE>
<P>
<BR>
<A NAME="19551"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19552"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19562"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19555"></A>addr
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19557"> </A>The starting address of the memory region to be unmapped.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19559"></A>len
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19561"> </A>The length, in bytes, of the memory region.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19563"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19564"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19565"> </A>If the memory region is successfully unmapped, <CODE>PR_SUCCESS</CODE>. 

<P><B>  <li></B>
<A NAME="19566"> </A>If the memory region is not successfully unmapped, <CODE>PR_FAILURE</CODE>. The error 
code can be retrieved via <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19570"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19571"> </A><CODE>PR_MemUnmap</CODE> removes the file mapping for the memory region (<CODE>addr</CODE>, <CODE>addr + len</CODE>). 
The parameter <CODE>addr</CODE> is the return value of an earlier call to <A HREF="priofnc.html#19516"  ><CODE>PR_MemMap</CODE></A>. 

<P>

<A NAME="19576"> </A><A NAME="PR_CloseFileMap"> </A><h4>
PR_CloseFileMap
</h4>

<A NAME="19577"> </A>Closes a file mapping.

<P>

<BR>
<A NAME="19578"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19579"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19580"></A>PRStatus PR_CloseFileMap(PRFileMap *fmap);
</PRE>
<P>
<BR>
<A NAME="19581"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19582"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19588"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19585"></A>fmap
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19587"> </A>The file mapping to be closed.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19589"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19590"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19591"> </A>If the file mapping is successfully closed, <CODE>PR_SUCCESS</CODE>. 

<P><B>  <li></B>
<A NAME="19592"> </A>If the file mapping is not successfully closed, <CODE>PR_FAILURE</CODE>. The error code can 
be retrieved via <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>. 

<P></ul>

<BR>
<A NAME="19596"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19600"> </A>When a file mapping created with a call to <A HREF="priofnc.html#19470"  ><CODE>PR_CreateFileMap</CODE></A> is no longer needed, 
it should be closed with a call to <A HREF="priofnc.html#19576"  ><CODE>PR_CloseFileMap</CODE></A>. 

<P>



<A NAME="19605"> </A>
<A NAME="Anonymous Pipe Function"> </A>
<h2>
Anonymous Pipe Function
</h2>


<A NAME="19606"> </A><A NAME="PR_CreatePipe"> </A><h4>
PR_CreatePipe
</h4>

<A NAME="19607"> </A>Creates an anonymous pipe and retrieves file descriptors for the read and write 
ends of the pipe.

<P>

<BR>
<A NAME="19608"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19609"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19610"></A>PRStatus PR_CreatePipe(<br>&nbsp;&nbsp;&nbsp;PRFileDesc **readPipe,<br>&nbsp;&nbsp;&nbsp;PRFileDesc **writePipe);
</PRE>
<P>
<BR>
<A NAME="19611"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19612"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19628"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19615"></A>readPipe
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19620"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> pointer. On return, this parameter 
contains the file descriptor for the read end of the pipe. 

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19622"></A>writePipe
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19627"> </A> A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> pointer. On return, this parameter 
contains the file descriptor for the write end of the pipe.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19629"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19630"> </A>The function returns one of these values:

<P>
<ul>
<B>  <li></B>
<A NAME="19631"> </A>If the pipe is successfully created, <CODE>PR_SUCCESS</CODE>. 

<P><B>  <li></B>
<A NAME="19632"> </A>If the pipe is not successfully created, <CODE>PR_FAILURE</CODE>. The error code can be 
retrieved via <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19636"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19637"> </A><CODE>PR_CreatePipe</CODE> creates an anonymous pipe. Data written into the write end of the 
pipe can be read from the read end of the pipe. Pipes are useful for interprocess 
communication between a parent and a child process. When the pipe is no longer 
needed, both ends should be closed with calls to <A HREF="priofnc.html#17887"  ><CODE>PR_Close</CODE></A>. 

<P>

<A NAME="19641"> </A><CODE>PR_CreatePipe</CODE> is currently implemented on
Unix, Linux, Mac OS X, and Win32 only. 

<P>



<A NAME="19643"> </A>
<A NAME="Polling Functions"> </A>
<h2>
Polling Functions
</h2>


<A NAME="19644"> </A>This section describes two of the most important polling functions provided by 
NSPR:

<P>

<A NAME="19648"> </A><A HREF="priofnc.html#19653"  ><CODE>PR_Poll</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19720"  ><CODE>PR_GetConnectStatus</CODE></A><CODE>
</CODE>
<P>

<A NAME="19653"> </A><A NAME="PR_Poll"> </A><h4>
PR_Poll
</h4>

<A NAME="19654"> </A>Detects when I/O is ready for a set of socket file descriptors.

<P>

<BR>
<A NAME="19655"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19656"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19657"></A>PRInt32 PR_Poll(<br>&nbsp;&nbsp;&nbsp;PRPollDesc *pds, <br>&nbsp;&nbsp;&nbsp;PRIntn npds, <br>&nbsp;&nbsp;&nbsp;PRIntervalTime timeout);
</PRE>
<P>
<BR>
<A NAME="19658"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19659"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19676"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19662"></A>pds
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19664"> </A>A pointer to an array of <CODE>PRPollDesc</CODE> structures.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19666"></A>npds
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19668"> </A>The number of elements in the <CODE>pds</CODE> array. If this parameter is zero, 
<CODE>PR_Poll</CODE> is equivalent to <A HREF="prthrd.html#15508"  ><CODE>PR_Sleep</CODE></A> with a timeout.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19673"></A>timeout
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19675"> </A>Amount of time the call will block waiting for I/O to become ready. If 
this time expires without any I/O becoming ready, <CODE>PR_Poll</CODE> returns 
zero.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19677"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19678"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19679"> </A>If successful, the function returns a positive number indicating the number of 
<CODE>PRPollDesc</CODE> structures in <CODE>pds</CODE> that have events.

<P><B>  <li></B>
<A NAME="19680"> </A>The value 0 indicates the function timed out.

<P><B>  <li></B>
<A NAME="19681"> </A>The value -1 indicates the function failed. The reason for the failure can be 
obtained by calling <A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<BR>
<A NAME="19685"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19686"> </A>This function returns as soon as I/O is ready on one or more of the underlying 
socket objects. A count of the number of ready descriptors is returned unless a 
timeout occurs, in which case zero is returned.

<P>

<A NAME="20991"> </A>The <CODE>in_flags</CODE> field of the <CODE>PRPollDesc</CODE> data structure should be set to the I/O 
events (readable, writable, exception, or some combination) that the caller is 
interested in. On successful return, the out_flags field of the PRPollDesc data 
structure is set to indicate what kind of I/O is ready on the respective descriptor. 
PR_Poll uses the out_flags fields as scratch variables during the call. If PR_Poll 
returns 0 or -1, the out_flags fields do not contain meaningful values and must not 
be used.

<P>

<A NAME="19688"> </A>The <CODE>PRPollDesc</CODE> structure is defined as follows:

<P>

<PRE>
<A NAME="19689"></A>struct PRPollDesc {<br>&nbsp;&nbsp;&nbsp;PRFileDesc* fd;<br>&nbsp;&nbsp;&nbsp;PRInt16 in_flags;<br>&nbsp;&nbsp;&nbsp;PRInt16 out_flags;<br>};
</PRE>
<P>
<PRE>
<A NAME="19690"></A>typedef struct PRPollDesc PRPollDesc;
</PRE>
<P>
<A NAME="19691"> </A>The structure has the following fields: 

<P>

<P>
<A NAME="19718"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19694"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19699"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing a socket or a pollable event. This field can be 
set to <CODE>NULL</CODE> to indicate to <CODE>PR_Poll</CODE> that this <CODE>PRFileDesc</CODE> object should 
be ignored.
<div class=note>On Unix, the <code>fd</code> field can be set to a pointer to any <code>PRFileDesc</code> object, including one representing a file or a pipe. Cross-platform applications should only set the <code>fd</code> field to a pointer to a <code>PRFileDesc</code> object representing a socket or a pollable event because on Windows the <code>select</code> function can only be used with sockets.</div>

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19701"></A>in_flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19703"> </A>A bitwise <CODE>OR</CODE> of the following bit flags: 

<P>
<ul>
<B>  <li></B>
<A NAME="19704"> </A><CODE>PR_POLL_READ</CODE>: fd is readable.

<P><B>  <li></B>
<A NAME="19705"> </A><CODE>PR_POLL_WRITE</CODE>: fd is writable.

<P><B>  <li></B>
<A NAME="19706"> </A><CODE>PR_POLL_EXCEPT</CODE>: fd has an exception condition.

<P></ul>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19708"></A>out_flags
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19710"> </A>A bitwise <CODE>OR</CODE> of the following bit flags:

<P>
<ul>
<B>  <li></B>
<A NAME="19711"> </A><CODE>PR_POLL_READ
</CODE>
<P><B>  <li></B>
<A NAME="19712"> </A><CODE>PR_POLL_WRITE
</CODE>
<P><B>  <li></B>
<A NAME="19713"> </A><CODE>PR_POLL_EXCEPT
</CODE>
<P><B>  <li></B>
<A NAME="19714"> </A><CODE>PR_POLL_ERR</CODE>: <CODE>fd</CODE> has an error. 

<P><B>  <li></B>
<A NAME="19715"> </A><CODE>PR_POLL_NVAL</CODE>: <CODE>fd</CODE> is bad<B>.
</B>
<P></ul>

<A NAME="19716"> </A>

<P>

<A NAME="19717"> </A>Note that the <CODE>PR_POLL_ERR</CODE> and <CODE>PR_POLL_NVAL</CODE> flags are used only in 
<CODE>out_flags</CODE>. The <CODE>PR_POLL_ERR</CODE> and <CODE>PR_POLL_NVAL</CODE> events are always 
reported by <CODE>PR_Poll</CODE>.

<P>
</TD>
  </TR>
</TABLE>


<P>


<A NAME="19720"> </A><A NAME="PR_GetConnectStatus"> </A><h4>
PR_GetConnectStatus
</h4>

<A NAME="19721"> </A>Get the completion status of a nonblocking connection.

<P>

<BR>
<A NAME="19722"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19723"></A>PRStatus PR_GetConnectStatus(const PRPollDesc *pd);
</PRE>
<P>
<BR>
<A NAME="19724"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19725"> </A>This function has the following parameter:

<P>

<P>
<A NAME="19731"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19728"></A>pd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19730"> </A>A pointer to a <CODE>PRPollDesc</CODE> satructure whose <CODE>fd</CODE> field is the socket and 
whose <CODE>in_flags</CODE> field must contain <CODE>PR_POLL_WRITE</CODE> and 
<CODE>PR_POLL_EXCEPT</CODE>.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19732"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19733"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19734"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="19735"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be retrieved via 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<A NAME="19739"> </A>If <CODE>PR_GetError</CODE> returns <CODE>PR_IN_PROGRESS_ERROR</CODE>, the nonblocking connection is 
still in progress and has not completed yet.Other errors indicate that the connection 
has failed.

<P>

<BR>
<A NAME="19740"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19744"> </A>After <A HREF="priofnc.html#18727"  ><CODE>PR_Connect</CODE></A> on a nonblocking socket fails with <CODE>PR_IN_PROGRESS_ERROR</CODE>, you 
may wait for the connection to complete by calling <A HREF="priofnc.html#19653"  ><CODE>PR_Poll</CODE></A> on the socket with the 
<CODE>in_flags</CODE> <CODE>PR_POLL_WRITE | PR_POLL_EXCEPT</CODE>. When <CODE>PR_Poll</CODE> returns, call 
<CODE>PR_GetConnectStatus</CODE> on the socket to determine whether the nonblocking 
connect has succeeded or failed.

<P>



<A NAME="21526"> </A>
<A NAME="Pollable Events"> </A>
<h2>
Pollable Events
</h2>


<A NAME="21535"> </A>A pollable event is a special kind of file descriptor. The only I/O operation you can 
perform on a pollable event is to poll it with the <CODE>PR_POLL_READ</CODE> flag. You cannot 
read from or write to a pollable event.

<P>

<A NAME="21536"> </A>The purpose of a pollable event is to combine event waiting with I/O waiting in a 
single <CODE>PR_Poll</CODE> call. Pollable events are implemented using a pipe or a pair of TCP 
sockets connected via the loopback address, therefore setting and/or waiting for 
pollable events are expensive operating system calls. Do not use pollable events for 
general thread synchronization; use condition variables instead.

<P>

<A NAME="21537"> </A>A pollable event has two states: set and unset. Events are not queued, so there is no 
notion of an event count. A pollable event is either set or unset.

<P>

<A NAME="21538"> </A>A new pollable event is created by calling <CODE>PR_NewPollableEvent</CODE>.

<P>

<A NAME="21540"> </A><CODE>PR_WaitForPollableEvent</CODE> blocks the calling thread until the pollable event is set, 
and then atomically unsetting the event before returning.

<P>

<A NAME="21541"> </A>Call <CODE>PR_SetPollableEvent</CODE> to set the pollable event.

<P>

<A NAME="21542"> </A>Call <CODE>PR_DestroyPollableEvent</CODE> (not <CODE>PR_Close</CODE>) to close and release resources of 
the pollable event.

<P>

<A NAME="21543"> </A>One can call <CODE>PR_Poll</CODE> with the <CODE>PR_POLL_READ</CODE> flag on a pollable event. Whe the 
pollable event is set, <CODE>PR_Poll</CODE> returns the the <CODE>PR_POLL_READ</CODE> flag set in the 
out_flags.

<P>

<A NAME="21596"> </A><A NAME="PR_NewPollableEvent"> </A><h4>
PR_NewPollableEvent
</h4>

<A NAME="21621"> </A>Create a pollable event file descriptor.

<P>

<BR>
<A NAME="21622"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="21623"></A>NSPR_API(PRFileDesc *) PR_NewPollableEvent( void);
</PRE>
<P>
<BR>
<A NAME="21624"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="21625"> </A>None.

<P>

<BR>
<A NAME="21665"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="21655"> </A>Pointer to PRFileDesc or NULL, on error.

<P>

<A NAME="21853"> </A><A NAME="PR_DestroyPollableEvent"> </A><h4>
PR_DestroyPollableEvent
</h4>

<A NAME="21845"> </A>Close the file descriptor associated with a pollable event and release related 
resources.

<P>

<BR>
<A NAME="21670"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<A NAME="21716"> </A><CODE>NSPR_API(PRStatus) PR_DestroyPollableEvent(PRFileDesc *event)</CODE>;

<P>

<BR>
<A NAME="21671"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<P>
<A NAME="21711"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="21708"></A>event
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="21710"> </A><CODE>Pointer to a PRFileDesc structure previously created 
via a call to PR_NewPollableEvent</CODE>.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="21672"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="21805"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="21806"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="21807"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be retrieved via 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<A NAME="21604"> </A><A NAME="PR_SetPollableEvent"> </A><h4>
PR_SetPollableEvent
</h4>

<A NAME="21732"> </A>Set a pollable event

<P>

<BR>
<A NAME="21684"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<A NAME="21733"> </A><CODE>NSPR_API(PRStatus) PR_SetPollableEvent( PRFileDesc *event);
</CODE>
<P>

<BR>
<A NAME="21765"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<P>
<A NAME="21776"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="21773"></A>event
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="21775"> </A><CODE>Pointer to a PRFileDesc structure previously created 
via a call to PR_NewPollableEvent</CODE>.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="21752"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="21822"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="21823"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="21824"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be retrieved via 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>

<A NAME="21608"> </A><A NAME="PR_WaitForPollableEvent"> </A><h4>
PR_WaitForPollableEvent
</h4>

<BR>
<A NAME="21695"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<A NAME="21782"> </A><CODE>NSPR_API(PRStatus) PR_WaitForPollableEvent( PRFileDesc *event );
</CODE>
<P>

<BR>
<A NAME="21696"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<P>
<A NAME="21793"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="21790"></A>event
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="21792"> </A><CODE>Pointer to a PRFileDesc structure previously created 
via a call to PR_NewPollableEvent</CODE>.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="21697"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="21833"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="21834"> </A>If successful, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="21835"> </A>If unsuccessful, <CODE>PR_FAILURE</CODE>. The reason for the failure can be retrieved via 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A>.

<P></ul>



<A NAME="19749"> </A>
<A NAME="Manipulating Layers"> </A>
<h2>
Manipulating Layers
</h2>


<A NAME="19750"> </A>File descriptors may be layered. For example, SSL is a layer on top of a reliable 
bytestream layer such as TCP. 

<P>

<A NAME="19751"> </A>Each type of layer has a unique identity, which is allocated by the runtime. The 
layer implementor should associate the identity with all layers of that type. It is 
then possible to scan the chain of layers and find a layer that one recognizes and 
therefore predict that it will implement a desired protocol. 

<P>

<A NAME="19752"> </A>A layer can be pushed onto or popped from an existing stack of layers. The file 
descriptor of the top layer can be passed to NSPR I/O functions, which invoke the 
appropriate version of the I/O methods polymorphically.

<P>

<A NAME="19753"> </A>NSPR defines three identities: 

<P>

<PRE>
<A NAME="19754"></A>#define PR_INVALID_IO_LAYER (PRDescIdentity)-1<br>#define PR_TOP_IO_LAYER (PRDescIdentity)-2<br>#define PR_NSPR_IO_LAYER (PRDescIdentity)0
</PRE>
<P><ul>
<B>  <li></B>
<A NAME="19755"> </A><CODE>PR_INVALID_IO_LAYER</CODE>: An invalid layer identify (for error return).

<P><B>  <li></B>
<A NAME="19756"> </A><CODE>PR_TOP_IO_LAYER</CODE>: The identity of the top of the stack.

<P><B>  <li></B>
<A NAME="19757"> </A><CODE>PR_NSPR_IO_LAYER</CODE>: The identity for the layer implemented by NSPR. 

<P></ul>

<A NAME="19758"> </A><CODE>PR_TOP_IO_LAYER</CODE> may be used as a shorthand for identifying the topmost layer of 
an existing stack. For example, the following lines of code are equivalent:

<P>

<PRE>
<A NAME="19759"></A>rv = PR_PushIOLayer(stack, PR_TOP_IO_LAYER, my_layer);<br>rv = PR_PushIOLayer(stack, PR_GetLayersIdentity(stack), my_layer);
</PRE>
<P>
<A NAME="19763"> </A><A HREF="priofnc.html#19786"  ><CODE>PR_GetUniqueIdentity</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19814"  ><CODE>PR_GetNameForIdentity</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19834"  ><CODE>PR_GetLayersIdentity</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19853"  ><CODE>PR_GetIdentitiesLayer</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19880"  ><CODE>PR_GetDefaultIOMethods</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19896"  ><CODE>PR_CreateIOLayerStub</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19922"  ><CODE>PR_PushIOLayer</CODE></A><CODE><br>
</CODE><A HREF="priofnc.html#19966"  ><CODE>PR_PopIOLayer</CODE></A><CODE>
</CODE>
<P>

<A NAME="19786"> </A><A NAME="PR_GetUniqueIdentity"> </A><h4>
PR_GetUniqueIdentity
</h4>

<A NAME="19787"> </A>Asks the runtime to allocate a unique identity for a layer identified by the layer's 
name.

<P>

<BR>
<A NAME="19788"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19789"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19790"></A>PRDescIdentity PR_GetUniqueIdentity(const char *layer_name);
</PRE>
<P>
<BR>
<A NAME="19791"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19792"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19798"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19795"></A>layer_name
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19797"> </A>The string associated with the creation of a layer's identity.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19799"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19800"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19804"> </A>If successful, the <A HREF="priotyp.html#17001"  ><CODE>PRDescIdentity</CODE></A> for the layer associated with the string 
specified in the layer named <CODE>layer_name</CODE>.

<P><B>  <li></B>
<A NAME="19805"> </A>If the function cannot allocate enough dynamic memory, it fails and returns the 
value <CODE>PR_INVALID_IO_LAYER</CODE> with the error code <CODE>PR_OUT_OF_MEMORY_ERROR</CODE>.

<P></ul>

<BR>
<A NAME="19806"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19807"> </A>A string may be associated with a layer when the layer is created. 
<CODE>PR_GetUniqueIdentity</CODE> allocates a unique layer identity and associates it with the 
string. The string can be subsequently passed to <A HREF="priofnc.html#19896"  ><CODE>PR_CreateIOLayerStub</CODE></A> to create 
a new file descriptor of that layer.

<P>

<BR>
<A NAME="19811"> </A><A NAME=""> </A><h5>

</h5>


<A NAME="19812"> </A>Call <CODE>PR_GetUniqueIdentity</CODE> only once for any particular layer name. 
If you're creating a custom I/O layer, cache the result, and then use that cached result every time you call <A HREF="priofnc.html#19896"  ><CODE>PR_CreateIOLayerStub</CODE></A>. 

<P>

<A NAME="19814"> </A><A NAME="PR_GetNameForIdentity "> </A><h4>
PR_GetNameForIdentity 
</h4>

<A NAME="19815"> </A>Gets the string associated with a layer's unique identity.

<P>

<BR>
<A NAME="19816"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19817"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19818"></A>const char* PR_GetNameForIdentity(PRDescIdentity ident);
</PRE>
<P>
<BR>
<A NAME="19819"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19820"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19826"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19823"></A>ident
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19825"> </A>A layer's identity.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19827"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19828"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19829"> </A>If successful, the function returns a pointer to the string associated with the 
specified layer. 

<P><B>  <li></B>
<A NAME="19830"> </A>If unsuccessful, the function returns <CODE>NULL</CODE>.

<P></ul>

<BR>
<A NAME="19831"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19832"> </A>A string may be associated with a layer when the layer is created. The string is 
copied by the runtime, and <CODE>PR_GetNameForIdentity</CODE> returns a pointer to that 
copy. 

<P>

<A NAME="19834"> </A><A NAME="PR_GetLayersIdentity"> </A><h4>
PR_GetLayersIdentity
</h4>

<A NAME="19835"> </A>Gets the unique identity for the layer of the specified file descriptor 

<P>

<BR>
<A NAME="19836"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19837"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19838"></A>PRDescIdentity PR_GetLayersIdentity(PRFileDesc* fd);
</PRE>
<P>
<BR>
<A NAME="19839"> </A><A NAME="Parameter"> </A><h5>
Parameter
</h5>


<A NAME="19840"> </A>The function has the following parameter:

<P>

<P>
<A NAME="19846"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19843"></A>fd
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19845"> </A>A pointer to a file descriptor.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19847"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19851"> </A>If successful, the function returns the <A HREF="priotyp.html#17001"  ><CODE>PRDescIdentity</CODE></A> for the layer of the specified 
file descriptor. 

<P>

<A NAME="19853"> </A><A NAME="PR_GetIdentitiesLayer"> </A><h4>
PR_GetIdentitiesLayer
</h4>

<A NAME="19854"> </A>Finds the layer with the specified identity in the specified stack of layers. 

<P>

<BR>
<A NAME="19855"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19856"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19857"></A>PRFileDesc* PR_GetIdentitiesLayer(<br>&nbsp;&nbsp;&nbsp;PRFileDesc* stack, <br>&nbsp;&nbsp;&nbsp;PRDescIdentity id);
</PRE>
<P>
<BR>
<A NAME="19858"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19859"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19872"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19862"></A>stack
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19867"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object that is a layer in a stack of layers.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19869"></A>id
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19871"> </A>The identity of the specified layer.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19873"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19874"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19875"> </A>If successful, a pointer to a file descriptor of the layer with the specified 
identity in the given stack of layers.

<P><B>  <li></B>
<A NAME="19876"> </A>If not successful, <CODE>NULL</CODE>. 

<P></ul>

<BR>
<A NAME="19877"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19878"> </A>The stack of layers to be searched is specified by the <CODE>fd</CODE> parameter, which is a layer 
in the stack. Both the layers underneath <CODE>fd</CODE> and the layers above <CODE>fd</CODE> are searched to 
find the layer with the specified identity. 

<P>

<A NAME="19880"> </A><A NAME="PR_GetDefaultIOMethods"> </A><h4>
PR_GetDefaultIOMethods
</h4>

<A NAME="19881"> </A>Gets the default I/O methods table.

<P>

<BR>
<A NAME="19882"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19883"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19884"></A>const PRIOMethods* PR_GetDefaultIOMethods(void);
</PRE>
<P>
<BR>
<A NAME="19885"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19889"> </A>If successful, the function returns a pointer to a <A HREF="priotyp.html#16863"  ><CODE>PRIOMethods</CODE></A> structure.

<P>

<BR>
<A NAME="19890"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19891"> </A>After using <CODE>PR_GetDefaultIOMethods</CODE> to identify the default I/O methods table, 
you can select elements from that table with which to build your own layer's 
methods table. You may not modify the default I/O methods table directly. You 
can pass your own layer's methods table to <A HREF="priofnc.html#19896"  ><CODE>PR_CreateIOLayerStub</CODE></A> to create your 
new layer.

<P>

<A NAME="19896"> </A><A NAME="PR_CreateIOLayerStub"> </A><h4>
PR_CreateIOLayerStub
</h4>

<A NAME="19897"> </A>Creates a new layer. 

<P>

<BR>
<A NAME="19898"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19899"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19900"></A>PRFileDesc* PR_CreateIOLayerStub(<br>&nbsp;&nbsp;&nbsp;PRDescIdentity ident<br>&nbsp;&nbsp;&nbsp;PRIOMethods const *methods);
</PRE>
<P>
<BR>
<A NAME="19901"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19902"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19915"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19905"></A>ident
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19907"> </A>The identity to be associated with the new layer.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19909"></A>methods
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19914"> </A>A pointer to the <A HREF="priotyp.html#16863"  ><CODE>PRIOMethods</CODE></A> structure specifying the functions for the 
new layer.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19916"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19917"> </A>A new file descriptor for the specified layer. 

<P>

<BR>
<A NAME="19918"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19919"> </A>A new layer may be allocated by calling <CODE>PR_CreateIOLayerStub</CODE>. The file 
descriptor returned contains the pointer to the I/O methods table provided. The 
runtime neither modifies the table nor tests its correctness.

<P>

<A NAME="19920"> </A>The caller should override appropriate contents of the file descriptor returned 
before pushing it onto the protocol stack.

<P>

<A NAME="19922"> </A><A NAME="PR_PushIOLayer"> </A><h4>
PR_PushIOLayer
</h4>

<A NAME="19923"> </A>Adds a layer onto the stack.

<P>

<BR>
<A NAME="19924"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19925"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19926"></A>PRStatus PR_PushIOLayer(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *stack, <br>&nbsp;&nbsp;&nbsp;PRDescIdentity id,<br>&nbsp;&nbsp;&nbsp;PRFileDesc *layer);
</PRE>
<P>
<BR>
<A NAME="19927"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19928"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19951"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19931"></A>stack
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19936"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the stack.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19938"></A>id
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19943"> </A>A <A HREF="priotyp.html#17001"  ><CODE>PRDescIdentity</CODE></A> object for the layer on the stack above which the new 
layer is to be added.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19945"></A>layer
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19950"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the new layer to be added 
to the stack. 

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19952"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19953"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19954"> </A>If the layer is successfully pushed onto the stack, <CODE>PR_SUCCESS</CODE>.

<P><B>  <li></B>
<A NAME="19955"> </A>If the layer is not successfully pushed onto the stack, <CODE>PR_FAILURE</CODE>. Use 
<A HREF="prerr.html#26127"  ><CODE>PR_GetError</CODE></A> to get additional information regarding the reason for the failure.

<P></ul>

<BR>
<A NAME="19959"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19960"> </A>A file descriptor for a layer (possibly allocated using <A HREF="priofnc.html#19896"  ><CODE>PR_CreateIOLayerStub</CODE></A>) may 
be pushed onto an existing stack of file descriptors at any time. The new layer is 
inserted into the stack just above the layer with the identity specified by <CODE>id</CODE>.

<P>

<A NAME="19964"> </A>Even if the <CODE>id</CODE> parameter indicates the topmost layer of the stack, the value of the 
file descriptor describing the original stack will not change. In other words, <CODE>stack</CODE> 
continues to point to the top of the stack after the function returns.

<P>

<BR>
<A NAME="21312"> </A><A NAME="Caution"> </A><h5>
Caution
</h5>


<A NAME="21315"> </A>Keeping the pointer to the stack even as layers are pushed onto the top of the stack 
is accomplished by swapping the contents of the file descriptor being pushed and 
the stack's current top layer file descriptor. 

<P>

<A NAME="21045"> </A>The intent is that the pointer to the stack remain the stack's identity even if 
someone (perhaps covertly) has pushed other layers. Some subtle ramifications:

<P>
<ul>
<B>  <li></B>
<A NAME="21048"> </A>The ownership of the storage pointed to by the caller's layer argument is 
relinquished to the runtime. Accessing the object via the pointer is not 
permitted while the runtime has ownership. The correct mechanism to access 
the object is to get a pointer to it by calling <A HREF="priofnc.html#19853"  ><CODE>PR_GetIdentitiesLayer</CODE></A>. 

<P><B>  <li></B>
<A NAME="21052"> </A>The contents of the caller's object are swapped into another container, 
including the reference to the object's destructor. If the original container was 
allocated using a different mechanism than used by the runtime, the default 
calling of the layer's destructor by the runtime will fail 
<A HREF="priofnc.html#19896"  ><CODE>PR_CreateIOLayerStub</CODE></A> is provided to allocate layer objects and template 
implementations). The destructor will be called on all layers when the stack is 
closed (see <A HREF="priofnc.html#17887"  ><CODE>PR_Close</CODE></A>). If the containers are allocated by some method other 
than <A HREF="priofnc.html#19896"  ><CODE>PR_CreateIOLayerStub</CODE></A>, it may be required that the stack have the layers 
popped off (in reverse order that they were pushed) before calling <A HREF="priofnc.html#17887"  ><CODE>PR_Close</CODE></A>. 

<P></ul>

<A NAME="19966"> </A><A NAME="PR_PopIOLayer"> </A><h4>
PR_PopIOLayer
</h4>

<A NAME="19967"> </A>Removes a layer from the stack.

<P>

<BR>
<A NAME="19968"> </A><A NAME="Syntax"> </A><h5>
Syntax
</h5>


<PRE>
<A NAME="19969"></A>#include &lt;prio.h&gt; 
</PRE>
<P>
<PRE>
<A NAME="19970"></A>PRFileDesc *PR_PopIOLayer(<br>&nbsp;&nbsp;&nbsp;PRFileDesc *stack,<br>&nbsp;&nbsp;&nbsp;PRDescIdentity id);
</PRE>
<P>
<BR>
<A NAME="19971"> </A><A NAME="Parameters"> </A><h5>
Parameters
</h5>


<A NAME="19972"> </A>The function has the following parameters:

<P>

<P>
<A NAME="19985"> </A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="4">
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19975"></A>stack 
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19980"> </A>A pointer to a <A HREF="priotyp.html#16807"  ><CODE>PRFileDesc</CODE></A> object representing the stack from which 
the specified layer is to be removed.

<P>
</TD>
  </TR>
  <TR>
    <TD VALIGN=TOP>
<PRE>
<A NAME="19982"></A>id
</PRE>
<P></TD>
    <TD VALIGN=TOP>
<A NAME="19984"> </A>Identity of the layer to be removed from the stack.

<P>
</TD>
  </TR>
</TABLE>


<P>


<BR>
<A NAME="19986"> </A><A NAME="Returns"> </A><h5>
Returns
</h5>


<A NAME="19987"> </A>The function returns one of the following values:

<P>
<ul>
<B>  <li></B>
<A NAME="19988"> </A>If the layer is successfully removed from the stack, a pointer to the removed 
layer.

<P><B>  <li></B>
<A NAME="19989"> </A>If the layer is not found in the stack or cannot be popped (for example, the 
bottommost layer), the function returns <CODE>NULL</CODE> with the error code 
<CODE>PR_INVALID_ARGUMENT_ERROR</CODE>.

<P></ul>

<BR>
<A NAME="19990"> </A><A NAME="Description"> </A><h5>
Description
</h5>


<A NAME="19991"> </A><CODE>PR_PopIOLayer</CODE> pops the specified layer from the stack. If the object to be removed 
is found, <CODE>PR_PopIOLayer</CODE> returns a pointer to the removed object The object then 
becomes the responsibility of the caller. 

<P>

<A NAME="19992"> </A>Even if the identity indicates the top layer of the stack, the reference returned is not 
the file descriptor for the stack and that file descriptor remains valid. In other 
words, <CODE>stack</CODE> continues to point to the top of the stack after the function returns.<B> 
</B>
<P>


<HR>
</BOOKCONTENT>

<FOOTERCONTENT>


            <b><a href="priotyp.html">
<FONT SIZE="2">Previous</a></FONT>&nbsp;&nbsp;&nbsp;&nbsp;</b>
<a href="index.html">
<b><FONT SIZE="2">Contents</a></FONT></b>&nbsp;&nbsp;&nbsp;&nbsp;
<a href="prntdb.html">
<b>
<FONT SIZE="2">
Next
</a>
</FONT>
</b>&nbsp;&nbsp;&nbsp;&nbsp;
 

   <FONT SIZE="-2">
   <P ALIGN="RIGHT">Last Updated <B>May 18, 2001</B>
   </FONT>
   <BR>

</FOOTERCONTENT>

</MAINCONTENT>



<?
require_once "{$config['file_root']}/includes/footer.inc.php"
?>
