<HTML>
<HEAD>
<TITLE>NSS 3.1 Project Plan</TITLE>
</HEAD>

<center>
<h2>NSS 3.1 Plan</h2>
<i><FONT SIZE="-1">

Newsgroup: 
<A HREF="news://news.mozilla.org/mozilla.dev.tech.crypto">mozilla.dev.tech.crypto</A><BR>

Engineering lead: 
<A HREF="mailto:relyea@netscape.com?subject=NSS 3.1 Plan">Bob Relyea</A><BR>

Product Manager: 
<A HREF="mailto:rolandj@netscape.com?subject=NSS 3.1 Plan">Roland Jones</A><BR>

Engineering manager: 
<A HREF="mailto:wtc@netscape.com?subject=NSS 3.1 Plan">Wan-Teh Chang</FONT></i></A>
</center>

<FONT SIZE="-1">
<br>Draft Version: 0.1.3
</FONT> 
<br>
<hr SIZE=0 WIDTH="100%">
<h3>Introduction</h3>
Earlier this year, we contributed NSS to the open source community. 
All the code that we could publish was released as NSS 3.0 on mozilla.org. 
To <a href="http://www.mozilla.org/projects/security/pki/nss/buildnss.html">build
NSS 3.0</a> requires a licensed copy of RSA's BSAFE Crypto-C Library to
provide low-level crypto functionality.
<p>The main goal of NSS 3.1 is to have a complete open-source implementation
of the NSS crypto libraries. A second goal is to establish a framework
to which developers and OEMs can contribute patches, such as assembler
code, to optimize performance on their platforms.
<p><b><font size=+1>Features and Tasks</font></b>
<ul>
<li>
NSPR 4.1 support (dual MPL/GPL license; beta 8/11, RTM candidate 8/25,
RTM 9/1).</li>

<li>
DES</li>

<li>
BigNum package based on <a href="http://linguist.dartmouth.edu/~sting/mpi/">
MPI: Arbitrary Precision Integer Arithmetic</a>.</li>

<li>
Unencumbered crypto code on top of the BigNum package, including RSA public
key, RSA private Key, Diffie-Hellman, Fortezza KEA, DSA sign, DSA verify,
key generation, param generation and verification, and other algorithms.
Work related to the RSA algorithms will begin on 9/21.</li>

<li>
A FIPS-compliant pseudo-random number generator</li>

<li>
An arcfour implementation</li>

<li>
<a href="#Root_Cert_Plan">Root CAs</a></li>

<ul>
<li>
Checked into the cvs server at mozilla.org.&nbsp; Each vendor has a separate
directory.</li>

<li>
Versioning of root CAs.</li>

<li>
Root CAs tied to applications, not NSS.</li>
</ul>

<li>
<a href="smime/">S/MIME Toolkit</a> </li>

<li>
Measure the performance of NSS 3.1</li>

<li>
Build system: simplify build procedure</li>

<li>
Document possible plans for releasing NSS as shared libraries/DLLs</li>
</ul>
<b><font size=+1>Bugs Fixed</font></b>
<ul>
<li>
TBD</li>
</ul>

<h3>
Release Focus</h3>

<ul>
<li>
Mozilla developers</li>
</ul>

<h3>
Platforms Supported</h3>

<ul>
<li>
NSS team builds, certifies, and supports the following platforms.</li>
</ul>

<table BORDER >
<tr>
<td VALIGN=CENTER><b>Platform</b></td>

<td VALIGN=CENTER><b>Build</b></td>

<td VALIGN=CENTER><b>Certify</b></td>

<td VALIGN=CENTER><b>Compiler(s)</b></td>
</tr>

<tr>
<td VALIGN=CENTER ROWSPAN="2" HEIGHT="43">AIX</td>

<td VALIGN=CENTER HEIGHT="43">4.3.3 (32 bit)</td>

<td VALIGN=CENTER HEIGHT="43">4.3.3</td>

<td VALIGN=CENTER HEIGHT="43">xlC/C++ 3.6.4</td>
</tr>

<tr>
<td VALIGN=CENTER HEIGHT="9">4.3.3 (64 bit)</td>

<td VALIGN=CENTER HEIGHT="9">4.3.3</td>

<td VALIGN=CENTER HEIGHT="9">xlC/C++ 3.6.4</td>
</tr>

<tr>
<td VALIGN=CENTER HEIGHT="61">Compaq Tru64</td>

<td VALIGN=CENTER HEIGHT="61">4.0D</td>

<td VALIGN=CENTER HEIGHT="61">4.0D&nbsp;
<br>5.0A</td>

<td VALIGN=CENTER HEIGHT="61">(cc) Digital C v5.6-071</td>
</tr>

<tr>
<td VALIGN=CENTER ROWSPAN="2" HEIGHT="58">HP-UX</td>

<td VALIGN=CENTER HEIGHT="58">11.0 (32 bit)</td>

<td VALIGN=CENTER HEIGHT="58">11.0 (32 bit)</td>

<td VALIGN=CENTER HEIGHT="58">C compiler: A.11.01.00</td>
</tr>

<tr>
<td VALIGN=CENTER HEIGHT="20">11.0 (64 bit)</td>

<td VALIGN=CENTER HEIGHT="20">11.0 (64 bit)</td>

<td VALIGN=CENTER HEIGHT="20">C compiler: A.11.00.00</td>
</tr>

<tr>
<td VALIGN=CENTER>Linux</td>

<td VALIGN=CENTER>RedHat 6.0</td>

<td VALIGN=CENTER>RedHat 6.0, 6.1, 6.2</td>

<td VALIGN=CENTER>egcs-1.1.2</td>
</tr>

<tr>
<td>Macintosh</td>

<td>8.5&nbsp;</td>

<td>8.5&nbsp;
<br>9.x</td>

<td>Metrowerks&nbsp;
<br>CodeWarrior</td>
</tr>

<tr>
<td VALIGN=CENTER>NT</td>

<td VALIGN=CENTER>NT 4.0 w/ SP 6a</td>

<td VALIGN=CENTER>NT 4.0 w/ SP 6a
<br>Win2000</td>

<td VALIGN=CENTER>VC++ 6.0 Service Pack 3</td>
</tr>

<tr>
<td>Windows</td>

<td>NT 4.0 w/ SP 6a</td>

<td>95 OSR2
<br>98 SE
<br>NT 4.0 w/ SP 6a
<br>Win2000</td>

<td>VC++ 6.0 Service Pack 3</td>
</tr>

<tr>
<td VALIGN=CENTER ROWSPAN="2" HEIGHT="66">Solaris</td>

<td VALIGN=CENTER HEIGHT="66">2.6</td>

<td VALIGN=CENTER HEIGHT="66">2.6 and 8 (32-bit and 64-bit)</td>

<td VALIGN=CENTER HEIGHT="66">WorkShop Compilers&nbsp;
<br>C/C++ version 4.2&nbsp;</td>
</tr>

<tr>
<td VALIGN=CENTER HEIGHT="12">8 (64-bit)</td>

<td VALIGN=CENTER HEIGHT="12">8 (64-bit)</td>

<td VALIGN=CENTER HEIGHT="12">WorkShop Compilers&nbsp;
<br>C/C++ version 5.0</td>
</tr>
</table>

<h3>
Doc Plan</h3>
Preliminary documentation for the <a href="smime/">S/MIME Toolkit</a> API will be added to the <a href="ref/">NSS
Reference Documentation</a>.</font>



<h3>
Schedule</h3>

<table BORDER >
<tr>
<td><b>Task</b></td>

<td><b>Date</b></td>
</tr>

<tr>
<td>BigNum package integrated, without performance tuning</td>

<td>7/28</td>
</tr>

<tr>
<td>Feature cut-off</td>

<td><font color="#000000">8/4</font></td>
</tr>

<tr>
<td>Beta</td>

<td>9/11</td>
</tr>

<tr>
<td>Certification (RTM Candidate)</td>

<td>10/6</td>
</tr>

<tr>
<td><b>RTM</b></td>

<td>10/13</td>
</tr>
</table>

<p>
<h3>
<a NAME="Root_Cert_Plan">Root Cert Plan</a></h3>
We need to change the way we handle updating root certs to meet
the following new goals:
<blockquote>
<li>
Be able to include the certs in the source tree.</li>

<li>
Allow vendors to replace our set of root certs with their own without conflicting
between their application and ours.</li>

<li>
Allow field upgrade of the root certs without building a new version of
the NSS libraries or new versions of the applications that use the libraries.</li>
</blockquote>
We discussed three possible solutions to the problems of multiple applications
defining their own list of trusted roots.
<p>Here is the summary of those solutions.

<h4>Option 1</h3>
<ul>Use the existing root cert update structure, making the list of cert
a dll, each application would maintain their own copy of the database.
<p>Advantages:
<blockquote>
<li>
Relatively simple to implement.</li>
</blockquote>
Disadvantages:
<blockquote>
<li>
Applications would not be able to share key and cert material.</li>

<li>
Unless additional code is added to protect one application's DB from another,
the chances of unrecoverable corruption because an application started
with a wrong database is high.</li>
</blockquote>
</ul>
<h4>Option 2</h4>
<ul>Use the existing root cert update structure, making the list of cert
a dll, and keep a separte internal DB version number for each application.
<p>Advantages:
<blockquote>
<li>
Also relatively simple to implement.</li>
</blockquote>
Disadvantages:
<blockquote>
<li>
This changes the database format. It may be possible to keep the DB major
version number so old applications can recognize the DB.</li>

<li>
We would have to manage an id space for each application.</li>

<li>
There is still potential for applications stomping on each other's trust
changes -- particularly if they use the same root cert.</li>
</blockquote>
</ul>
<h4>Option 3</h4> 
<ul>Go to a Stan-like structure. ("Stan" is the working name for NSS 4.0, which will include
a new, multi-process-safe cert database and a dynamically loadable cert/key store.) Implement enough of Stan to load an internal
DB (potentially internal) and "internal" RO trust DB (external).
<p>Advantages:
<blockquote>
<li>
We can support all our existing semantic, plus many new ones.</li>

<li>
It takes us down the first step toward stan-like Certificate structure.</li>

<li>
It splits trust from the key and cert DBs.</li>
</blockquote>
Disadvantages:
<blockquote>
<li>
It's a lot more complicated than the other proposals.</li>
</blockquote>
</ul>

<h3>
Option 3: Implementation</h3>
In fleshing out option 3, we need to decide how to implement
it and what can we do to reduce the risks involved.
<p>First we should assume minimal changes to the PKCS #11 loading code.
Rather than including the whole Stan infrastructure for loading PKCS #11
modules, we can simply use the existing structure, with code that can help
'discover' the applications trusted root cert base.
<p>We also don't need to implement the Stan wrapped key semantics for this
to work.
<p>We will have to introduce the new Stan trust module, at least for a
single trust domain. We only need enought to implement it under the existing
API.
<p>The basic design would be to have the root certs live in a read-only
'Database'. This DB would be accessed through a separate PKCS #11 module.
The cert code would be modified to only search for certificates through
PKCS #11, and not through the cert DB code.
<p>Trust will include both accept and reject versions of trust. Trust would
be merged through a heiarchy of trusted modules.
<p>Certificate verification would have to be modified to support this trust
information.
<ul>
<li><b>Step 1</b>. Modify the Hi cert code to always use PCKS #11 and it's
own local cache to search for certificates. This will involve designing
and implementing at least a simple cert caching scheme.
<li><b>Step 2</b>. Modify the internal PKCS #11 module to export all the
certificates, not just the user certificates.
<li><b>Step 3</b>. Modify the Trust parsing code to handle multiple sources
of trust.
<li><b>Step 4</b>. Add code the the PKCS #11 load modules to load the RO
version of the database.
</ul>
<p>Issues that need to be addressed:
<ul>
<li>
How do you 'discover' the PKCS #11 static load module if one isn't already
loaded.</li>

<li>
Need to understand how much of the cert code has to change.</li>
</ul>

<h3>
Useful links</h3>

<ul>
<li>
<a href="index.html">NSS project page</a></li>

<li>
<a href="ref/">NSS reference documentation</a></li>
</ul>

</body>
</html>
