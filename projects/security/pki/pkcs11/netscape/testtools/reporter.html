<?php

$html_title = 'Reporter: A Tool to Collect and Compile Test Results';

$menu = array(
    'id' => 'default',
);

require_once "{$config['file_root']}/includes/header.inc.php"

?>

<center>
<h2>Reporter: A Tool to Collect and Compile Test Results</h2>
<i><FONT SIZE="-1">

Newsgroup: 
<A HREF="news://news.mozilla.org/mozilla.dev.tech.crypto">mozilla.dev.tech.crypto</A><BR>

Technical contact: 
<A HREF="mailto:relyea@netscape.com?subject=Regress Tool Feedback">Bob Relyea</A><BR>

Yell at the manager: 
<A HREF="mailto:lord@netscape.com?subject=Regress Tool Feedback">Bob Lord</A></FONT></i>
</center>

<h3>
Overview</h3>
<B>Reporter</B>is a productivity tool that automates the web indexing
of regression results generated by the <A HREF="regress.html">regress
</A>tool. The tool takes a specfile (defined below) as input, which
defines the Component/Test Suite/Platform topology of the report directory
structure. The tool then parses all the individual regress summary
files found at the lowest level of the reporting hierarcy and updates all
the intermediate index.html files.  The reporter tool is expected
to automate the routine maintenance of updating web content to form an
orderly and predictable testing results web, that can be reindexed automatically.
<BR>
<TABLE BORDER COLS=1 WIDTH="100%" >
<TR>
<TD><IMG SRC="reporter.jpg" HEIGHT=672 WIDTH=465>&nbsp;
<BR><B>Figure 1: Architecture Overview</B></TD>
</TR>
</TABLE>
&nbsp;
<h3>
Command Line Arguments</h3>
&nbsp;
<TABLE BORDER COLS=1 WIDTH="100%" >
<TR>
<TD><B>reporter&nbsp; specfile=</B><I>&lt;filename> </I><B>[rptdir=</B><I>&lt;dirname></I><B>]
[debug]</B>&nbsp;
<LI>
<I>Filename </I>is either an absolute path or relative path to an existing
filename that contains a specification (as defined below).</LI>

<LI>
<I>Dirname </I>is an optional parameter that overrides the dirname line
in the general section of the specification file (see below).</LI>

<LI>
The optional <B>debug </B>argument will turn on stdout debug information
defined below -- soft errors.</LI>

<BR><B>Note:</B> The arguments above are order independent.</TD>
</TR>
</TABLE>
&nbsp;
<h3>
Error Reporting</h3>
The following table defines <B>hard error</B> will will prevent reporter
from completing its task.
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Error Code</B></TD>

<TD><B>Description</B></TD>
</TR>

<TR>
<TD>NO_ERROR (<B>0</B>)</TD>

<TD>Program ran to completion and completed its indexing job.</TD>
</TR>

<TR>
<TD>ERR_NO_RPTDIR (<B>1</B>)</TD>

<TD>Program could not open the directory <I>rptdir </I>(as defined in [General]
section or passed in on command line).&nbsp;</TD>
</TR>

<TR>
<TD>ERR_NO_SPECFILE (<B>2</B>)</TD>

<TD>Program could not open the specfile passed in on the command line.</TD>
</TR>

<TR>
<TD>ERR_NO_GENERAL (<B>3</B>)</TD>

<TD>Could not locate a [General] section in the specfile.</TD>
</TR>

<TR>
<TD>ERR_NO_RPTDIR (<B>4)</B></TD>

<TD>Could not locate a rptdir= line in the [General] section.&nbsp;&nbsp;
Only if rptdir not passed in on the command line.</TD>
</TR>

<TR>
<TD>ERR_NO_COMPONENT (<B>5</B>)</TD>

<TD>Specification file does not contain a [Component] section.&nbsp;</TD>
</TR>

<TR>
<TD>ERR_NO_TESTSUITE (<B>6</B>)</TD>

<TD>Specification file does not contain a [TestSuite] section.</TD>
</TR>

<TR>
<TD>ERR_NO_PLATFORM (<B>7</B>)</TD>

<TD>Specification file does not contain a [Platform] section.</TD>
</TR>

<TR>
<TD>ERR_IDX_NOWRITE (<B>8</B>)</TD>

<TD>Failed to write (or over-write) one of the index.html files.&nbsp;</TD>
</TR>

<TR>
<TD>ERR_USAGE (<B>9</B>)</TD>

<TD>Provided an invalid or undefined argument. See usage.</TD>
</TR>

<TR>
<TD>ERR_BADSECTIONS (<B>10</B>)</TD>

<TD>One of the required fields in one of the sections was missing.</TD>
</TR>
</TABLE>


<P>The following table defines messages which are generated on standard
output (if and only if debug parameter is supplied) to log <B>"soft"</B>
errors -- errors that can be worked around:
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Error Message - reported to standard output</B></TD>

<TD><B>Description</B></TD>
</TR>

<TR>
<TD><B>Fatal error: One of the required fields (</B><I>field</I><B>) in
</B><I>&lt;section name></I><B> was not present.</B></TD>

<TD>One of the fields required in provide section was missing, see specification.,
corresponds to the hard error ERR_BADSECTIONS.</TD>
</TR>

<TR>
<TD>r<B>eporter:&nbsp; Malformed summary file</B> <I>&lt;filename></I>
<B>: could not locate</B> <I>&lt;field></I> <B>field.</B></TD>

<TD>The summary file, identified by &lt;filename> did not conform to the
specifiction (see below).</TD>
</TR>

<TR>
<TD><B>reporter: Could not open directory</B><I> &lt;dirname></I> <B>defined
in section</B> <I>&lt;section name></I>.</TD>

<TD>Attempted to open a directory which did not exist.&nbsp; The <B>dirname
</B>variable as composed as follows:&nbsp;
<LI>
For section = [Component-name], dirname = &lt;rptdir>/&lt;component dirname></LI>

<LI>
For section = [TestSuite-name], dirname = &lt;rptdir>/&lt;component dirname>/&lt;testsuite
dirname></LI>

<LI>
For section = [Platform-name], dirname = &lt;rptdir>/&lt;component dirname>/&lt;testsuite
dirname>/&lt;platform dirname></LI>
</TD>
</TR>

<TR>
<TD><B>Fatal error: error code =</B> <I>&lt;number></I> : <I>message</I></TD>

<TD>Additionally, all hard errors will be reported, as defined in the table
above, to standard output., use for all ERR_ codes defined above that don't
have a more specific message defined in this table.</TD>
</TR>

<TR>
<TD>reporter: Usage: <B>reporter&nbsp; specfile=</B><I>&lt;filename> </I><B>[rptdir=</B><I>&lt;dirname></I><B>]
[debug]</B>&nbsp;</TD>

<TD>Corresponds to ERR_USAGE defined above.</TD>
</TR>
</TABLE>
&nbsp;
<h3><a name="specfiles">Format of Summary Specification Files</a></h3>
As a regression suite completes (driven by the regress tool), it writes
out an HTML output file, and a regression summary specification file.&nbsp;
Both of these files are utilized in the creation of the higher level summary
index files.

<P><B>The following defines the contents of the reporter summary
specification file, as generated by <A HREF="regress.html">regress</A>:</B>
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Specification File Element</B></TD>

<TD><B>Description of Element</B></TD>
</TR>

<TR>
<TD><B>[Status]</B></TD>

<TD>Is the only block in this specification file</TD>
</TR>

<TR>
<TD><B>mut=description</B></TD>

<TD>Defines a description for the <B>module under test</B> 
</TD>
</TR>

<TR>
<TD><B>mutversion=versionstring</B></TD>

<TD>Defines a <B>version string</B> for the collection of tests. It is
assumed that each test will execute against this higher level versionstring
version, and that the results will be reported against this versionstring.</TD>
</TR>

<TR>
<TD><B>platform=&lt;string></B></TD>

<TD>Defines the platform the tests were run under (e.g., HP UX 1.0, Solaris
2.4.1, etc.)</TD>
</TR>

<TR>
<TD><B>pass=&lt;number></B></TD>

<TD>Number of tests that passed.</TD>
</TR>

<TR>
<TD><B>fail=&lt;number></B></TD>

<TD>Number of tests that failed due to non-zero return codes, timeouts,
OR any other abnormality when running the test.</TD>
</TR>

<TR>
<TD><B>knownFail=&lt;number></B></TD>

<TD>Number of tests that were known to fail because a bug number was specified
in its regress specfile.TD>
</TR>

<TR>
<TD><B>malformed=&lt;number></B></TD>

<TD>Number of tests with bad headers (see <A HREF="regress.html">regress
specfile specifications</A>).</TD>
</TR>
</TABLE>
&nbsp;
<h3>
Format of Reporter Input Specification File</h3>
The following defines the contents of the reporter input specification
file:
<BR>&nbsp;
<BR>&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Section / Field names</B></TD>

<TD><B>Description</B></TD>
</TR>

<TR>
<TD><B>[General]</B>
<BR><B>rptdir=</B><I>&lt;directory><BR>
</I><B>[index=</B><I>filename</I><B>]</B></TD>

<TD>
<LI>
The <B>rptdir </B>entry defines the directory location of an existing directory
whose directory topology exists as defined by the [Component-name], [TestSuite-name],
and [Platform-name] sections.&nbsp; The rptdir directory must exist, if
not the command will exit with ERR_NO_RPTDIR.&nbsp; Only a single [General]
section should be provided in a specification file.</LI>

<LI>
If the index entry is present, the filename is the name of the computed
index (e.g., index.html, or index.htm).</LI>
</TD>
</TR>

<TR>
<TD><B>[Component-</B><I>name</I><B>]</B>
<BR><B>desc=</B><I>&lt;description></I>
<BR><B>version=</B><I>&lt;version></I>
<BR><B>dirname</B><I>=&lt;directory name></I></TD>

<TD>
<LI>
<B>[Component-</B><I>name</I><B>]</B> is a high level component, such as
a complete library.&nbsp; For example, NSPR 2.0 or NETLIB, or the Security
Library.&nbsp; Multiple [Component-name] sections can be present in a specification
file.</LI>

<LI>
<B>desc </B>is a string that describes the component (e.g., Security Library).</LI>

<LI>
<B>version </B>defines the version of the library that the filed reports
should apply to (this is an expected version string)</LI>

<LI>
<B>dirname </B>defines the directory name (no / or .. allowed -- just the
directory name) which is expected to be present under the dirname supplied
in the [General] section or passed in on the command line.</LI>
</TD>
</TR>

<TR>
<TD><B>[TestSuite-<I>name</I>]</B>
<BR><B>desc=</B><I>description</I>&nbsp;
<BR><B>component=</B><I>name</I>
<BR><B>dirname</B><I>=&lt;directory name></I>&nbsp;
<BR>&nbsp;</TD>

<TD>
<LI>
<B>[TestSuite-</B><I>name</I><B>]</B> defines an API test suite (a sub-component)
of the higher level component.&nbsp; For example, in the Security Library,
APIs such as PKCS#5, PKCS#11, certificates/keys will each have their own
indepent test suites (all driven by a different <A HREF="regress.html">regression
</A>specification). Multiple [TestSuite-name] sections can be present,
however component must refer to a provided component name section.</LI>

<LI>
<B>desc </B>is a string that describes the suite (e.g., PKCS#5).&nbsp;</LI>

<LI>
<B>component </B>defines what component name this test suite is contained
in.</LI>

<LI>
<B>dirname </B>defines the directory name (no / or .. allowed -- just the
directory name) which is expected to be present under the &lt;dirname>/&lt;component
name> directory.</LI>
</TD>
</TR>

<TR>
<TD><B>[Platform-</B><I>name</I><B>]</B>
<BR><B>desc=</B><I>description</I>&nbsp;
<BR><B>dirname</B><I>=&lt;directory name></I>
<BR><B>testsuite-</B><I>name=</I><B>yes|no</B></TD>

<TD>
<LI>
<B>[Platform-<I>name</I>]</B> defines what platforms each test suite is
currently available on.&nbsp; It is expected that this mapping is updated
as suites are ported and executed against target platforms.</LI>

<LI>
<B>desc </B>is a string that describes the platform (e.g., Solaris 2.4.1).&nbsp;</LI>

<LI>
<B>dirname </B>defines the directory name (no / or .. allowed -- just the
directory name) which is expected to be present under the &lt;dirname>/&lt;component
name> directory.</LI>

<LI>
<B>testsuite-name</B> is defined to be either yes or no.&nbsp; yes means
that the TestSuite&nbsp;</LI>
</TD>
</TR>
</TABLE>
&nbsp;
<h3>
Pseudo-Code of Reporter Program Flow</h3>
<B>Data structures:</B>
<TABLE BORDER >
<TR>
<TD>enum DirNodeType{ DIRROOT, COMPONENT, TSUITE, PLATFORM, FILE} ;&nbsp;

<P>typedef struct _StatusNode {
<BR>&nbsp;&nbsp;&nbsp; char *<B>mut</B>;&nbsp; /* module under test */
<BR>&nbsp;&nbsp;&nbsp; char *<B>mutversion</B>;&nbsp; /* module under test
version */
<BR>&nbsp;&nbsp;&nbsp; char *<B>platform</B>;&nbsp; /* platform string
*/
<BR>&nbsp;&nbsp;&nbsp; int <B>stats</B>[4] ;&nbsp; /*&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stats[0] = <B>pass</B>;&nbsp;
number of tests passed&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stats[1] = <B>fail</B>;&nbsp;
number of tests failed&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stats[2] = <B>knownfail</B>;&nbsp;&nbsp;
number of tests known to fail&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stats[3] = <B>malformed</B>;&nbsp;&nbsp;
number of malformed tests&nbsp; */
<BR>} StatusNode;

<P>typedef struct _DirectoryNode {<BR>
&nbsp;&nbsp;&nbsp; DirNodeType <B>dntype</B>;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; char *<B>name</B>;&nbsp;&nbsp;&nbsp; /* section
name */&nbsp;
<BR>&nbsp;&nbsp;&nbsp;&nbsp; char *<B>desc</B>;&nbsp;&nbsp;&nbsp;&nbsp;
/* desc= within a section */
<BR>&nbsp;&nbsp;&nbsp;&nbsp; char *<B>dirname</B>;&nbsp; /* dirname= within
a section */
<BR>&nbsp;&nbsp;&nbsp;&nbsp; char *<B>mostrecent</B>;&nbsp; /* only used
on dntype = PLATFORM */
<BR>&nbsp;&nbsp;&nbsp;&nbsp; StatusNode *<B>statnode</B>;&nbsp; /* The
status for the current level */
<BR>&nbsp;&nbsp;&nbsp;&nbsp; DirectoryNode *<B>dnlist</B>[];&nbsp;&nbsp;
/* list of pointers */<BR>
} DirectoryNode;
<BR>&nbsp;</TD>
</TR>
</TABLE>


<P><B>Program logic:</B>
<TABLE BORDER >
<TR>
<TD>

<P>/* 1.0 Process specification file */
<BR>Parse command line arguments, on error generate ERR_USAGE, otherwise
set <B>debug</B>, <B>rptdir</B>, <B>specfile </B>variables.
<BR>Open <B>specfile</B>, if not then&nbsp; ERR_NO_SPECFILE.<BR>
if index entry in [General Section] set index to filename, otherwise index
= index.html.
<BR>if no [General Section] then ERR_NO_GENERAL.<BR>
if <B>rptdir</B>=NULL and no <B>rptdir </B>in [General Section] then ERR_NO_RPTDIR.

<P>/* 1.1 Add all component names to DirectoryNode tree */
<BR>Create DirectoryNode,&nbsp; set as&nbsp; root node, set as type DIRROOT.
<BR>Iterate each section name that starts with Component-name {
<BR>&nbsp;&nbsp;&nbsp; Construct DirectoryNode <B>new</B>, add to root
node, set as <B>dntype = </B>COMPONENT.
<BR>&nbsp;&nbsp;&nbsp; Add<B> name,desc,version, and dirname</B> to <B>new
</B>node.<BR>
}

<P>/* 1.2 Add all test suite names to DirectoryNode tree */
<BR>Iterate each section name that starts with TestSuite-name {
<BR>&nbsp;&nbsp;&nbsp; Locate component where component-name in section
matches.
<BR>&nbsp;&nbsp;&nbsp; If no match, then print warning message
<BR>&nbsp;&nbsp;&nbsp; otherwise {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Construct <B>new </B>DirectoryNode.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set node <B>desc,dirname</B>
values, set as <B>dntype </B>= TESTSUITE
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add <B>new </B>node to component
node <B>dnlist</B>.
<BR>&nbsp;&nbsp;&nbsp; }
<BR>}

<P>/* 1.3 Add all test suite names to DirectoryNode tree */
<BR>Iterate each section name that starts with Platform-name {&nbsp;&nbsp;&nbsp;
<BR>&nbsp;&nbsp;&nbsp; Locate testsuite where testsuite-name in section&nbsp;
matches.
<BR>&nbsp;&nbsp;&nbsp; If no match, then print warning message
<BR>&nbsp;&nbsp;&nbsp; otherwise {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Construct <B>new </B>DirectoryNode.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set node <B>desc,dirname</B>
values, set <B>dntype </B>= PLATFORM.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Add <B>new </B>node to test
suite node <B>dnlist</B>.
<BR>&nbsp;&nbsp;&nbsp; }
<BR>}

<P>/* 2.0 Open each of the status nodes, and augment tree with HTML file
objects */
<BR><B>AccumulatedPath </B>= <B>rptdir</B>
<BR>Select each node <B>n</B>&nbsp; starting from top of tree {
<BR>&nbsp;&nbsp; Concatenate <B>dirname </B>to <B>AccumulatedPath</B>.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; if (<B>n.dntype </B>== PLATFORM) {&nbsp; /*
only look at leaf nodes */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Open directory pointed
to by <B>AccumulatedPath</B>, and process each <B>file </B>{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
If <B>file </B>ends in&nbsp; ".htm" or file ends in ".html" {&nbsp; /*
file is a report */
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Is there a corresponding report file? If so {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Open status file and parse contents into a StatusNode (<B>sn</B>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
If status file not malformed {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Construct a <B>new </B>DirectoryNode.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set <B>statnode </B>= <B>sn</B>
<BR><B>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</B>Set <B>dirname </B>as <B>file;&nbsp;&nbsp; /* this should be named
something more abstract than dirname */</B>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Set node <B>dntype </B>= FILE.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Add <B>node </B>to current node <B>n.dnlist</B>.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
} else print error message
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else print error message.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; }
<BR>&nbsp;&nbsp;&nbsp; Remove&nbsp; <B>dirname </B>from <B>AccumulatedPath</B>
<BR>}

<P>/* 2.1 Select most recent report at the PLATFORM level and store in
tree */
<BR>For each <B>node </B>that is a PLATFORM node,&nbsp;
<BR>&nbsp;&nbsp; Iterate through the <B>dnlist </B>of FILE nodes and select
the most recent <B>filename </B>(based on string prior to ".").
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Set <B>node.most.recent</B> = <B>filename</B>.

<P>/* 2.2&nbsp; Calculate suite results */
<BR>For each node that is a TESTSUITE node,
<BR>&nbsp;&nbsp;&nbsp; Construct new StatusNode, all values zero, set node.statnode.
<BR>&nbsp;&nbsp;&nbsp; For each PLATFORM node in dnlist,&nbsp; for each
stat, node.stats[i] += platform node stats values.

<P>/* 2.3 Calculate component results */
<BR>For each node that is a COMPONENT node,
<BR>&nbsp;&nbsp;&nbsp; Construct new StatusNode, all values zero,&nbsp;
set node.statnode.
<BR>&nbsp;&nbsp;&nbsp; For each PLATFORM node in dnlist,&nbsp; for each
stat, node.stats[i] += platform node stats values.

<P>/* 3.0 Write out all index files at ROOT, COMPONENT, SUITE, and PLATFORM
level */
<BR>for each <B>node </B>in tree do {
<BR>&nbsp;&nbsp; switch (<B>node.dntype</B>)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ROOT:&nbsp;&nbsp; Generate HTML report
from dnlist as per HTML formatting.
<BR>&nbsp;&nbsp;&nbsp;&nbsp; COMPONENT:&nbsp; Generate HTML report from
dnlist as per HTML formatting.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SUITE:&nbsp;&nbsp; Generate HTML report
from dnlist as per HTML formatting.
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PLATFORM:&nbsp;&nbsp; Generate HTML
report from dnlist as per HTML formatting.
<BR>}
<BR>&nbsp;<BR>
return NO_ERROR.</TD>
</TR>
</TABLE>
&nbsp;
<BR>&nbsp;
<h3>
Format of Generated index.htm files</h3>
&nbsp;
<TABLE BORDER >
<TR>
<TD><B>Level</B></TD>

<TD><B>HTML Format</B></TD>
</TR>

<TR>
<TD>ROOT</TD>

<TD>&lt;HTML><BR>
&lt;HEAD>&lt;/TITLE>&lt;/TITLE>&lt;/HEAD><BR>
&lt;BODY>
<BR>&lt;TABLE>
<BR>For each component in ROOT {
<BR>&lt;TR>&lt;TD>&lt;A HREF="&lt;filename>/&lt;index>">desc&lt;/A>&lt;/TD>&lt;/TR>
<BR>}
<BR>&lt;/TABLE>
<BR>&lt;/BODY><BR>
&lt;/HTML></TD>
</TR>

<TR>
<TD>COMPONENT</TD>

<TD>&lt;HTML><BR>
&lt;HEAD>&lt;/TITLE>&lt;/TITLE>&lt;/HEAD><BR>
&lt;BODY>
<BR>&lt;TABLE>
<BR>For each suite in component node {
<BR>&lt;TR>&lt;TD>&lt;A HREF="&lt;filename>/&lt;index>">desc&lt;/A>&lt;/TD>&lt;/TR>
<BR>}
<BR>&lt;/TABLE>
<BR>&lt;/BODY><BR>
&lt;/HTML></TD>
</TR>

<TR>
<TD>SUITE</TD>

<TD>&lt;HTML><BR>
&lt;HEAD>&lt;/TITLE>&lt;/TITLE>&lt;/HEAD><BR>
&lt;BODY>
<BR>&lt;TABLE>
<BR>&lt;TR>&lt;TD>&lt;/TD>&lt;/TR>
<BR>&lt;/TABLE>
<BR>&lt;/BODY><BR>
&lt;/HTML></TD>
</TR>

<TR>
<TD>PLATFORM</TD>

<TD>&lt;HTML><BR>
&lt;HEAD>&lt;/TITLE>&lt;/TITLE>&lt;/HEAD><BR>
&lt;BODY>
<BR>&lt;TABLE>
<BR>&lt;TR>&lt;TD>&lt;/TD>&lt;/TR>
<BR>&lt;/TABLE>
<BR>&lt;/BODY><BR>
&lt;/HTML></TD>
</TR>
</TABLE>
&nbsp;

<h3>
Sample Reporter Input Specification File</I>
The following defines a sample input specification file to reporter (which
is highly domain specific):
<BR>&nbsp;
<TABLE BORDER WIDTH="100%" >
<TR>
<TD>[General]
<BR>dirname=/u/zigbert/saw/projects/hardcore/prj-ttools/testing/rptroot&nbsp;

<P>[Component-seclib]&nbsp;
<BR>desc=Security Library
<BR>version=2.0
<BR>dirname=security-library

<P>[TestSuite-pkcs5]
<BR>desc=Public Key Cryptography Standards # 5
<BR>component=seclib
<BR>dirname=pkcs5

<P>[TestSuite-crypto]
<BR>desc=Cryptographic Functionality (bulk ciphers, RSA, DSA)
<BR>component=seclib
<BR>dirname=libcrypto

<P>[Platform=hp10_2]&nbsp;
<BR>desc=HP UX 10.2
<BR>dirname=hpux10_2
<BR>testsuite-pkcs5=yes
<BR>testsuite-crypto=yes

<P>[Platform=sol2_4]
<BR>desc=Solaris 2.4.1
<BR>dirname=sol2_4_1
<BR>testsuite-pkcs5=yes</TD>
</TR>
</TABLE>
&nbsp;



<?
require_once "{$config['file_root']}/includes/footer.inc.php"
?>
